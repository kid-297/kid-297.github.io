<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[NIO 基础]]></title>
    <url>%2F2021%2F04%2F20%2Fnetty%2FNIO%20%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[NIO 和 IO 的区别IO 是以流的方式进行数据传输，它是同步阻塞类型。我们可以将流看成生活中的水流，它是单向的。NIO 是以通道的方式进行数据传输，它是同步非阻塞类型。我们可以将通道看成铁道，通道是不存储数据的，它采用buffer来存储数据，由通道运输到两端。它是一个双向的。 缓冲区的数据存取基础类型中，除了boolean没有buffer以外，NIO给每个类型都提供了相应的buffer.java.nio.Buffer; |– ByteBuffer |– CharBuffer |– IntBuffer |– ShortBuffer其中，buffer 提供了一些方法，用于存储和输出数据，以ByteBuffer为例： 1234567891011//1. 实例化一个buffer,大小为1024字节ByteBuffer byteBuffer = ByteBuffer.allocate(1024);//2.取数据 byteBuffer.get();//3.存数据byteBuffer.put();//4.rewind(); 可重复读//5.clear(); 回到最初状态，但是数据不清空//6.mark(); 标记 搭配 reset()；重复 使用 四个核心属性： capacity：容量，表示缓冲区中最大存储数据容量，一但声明，不允许改变。 limit：界限，表示缓冲区中可操作数据大小。（limit 后数据不能进行读写） position：位置，表示缓冲区中正在操作数据的位置。 positon &lt;= limit &lt;= capacity 直接缓冲区和非直接缓冲区 非直接缓冲区：通过allocate() 方法分配缓冲区，在JVM内存中 直接缓冲区：通过 allocateDirect() 分配直接缓冲区。建立在物理内存中 管道channel用于源节点和目标节点的连接。在java nio 中负责缓冲区中的数据传输。类似于流，但是不能访问数据，只能与Buffer进行交互。 DMA:直接存储器 最开始，由CPU进行IO接口请求处理，启用多个线程。如果没有数据，则该线程则进入等待状态。后又采用DMA总线方式控制线程。但DMA还是需要向CPU请求资源，后将DMA替换成Channel。一个完全独立的处理器，用来处理IO.无需向CPU申请。 Java.nio.channels.channel 接口： FileChannel SocketChannel ServerSocketChannel DatagranChannel 获取通道 getChannel 本地IO FileInputStream / FileOutputStream RandomAccessFile 网络IO Socket ServerSocket DatagramSocket JDK 1.7 open Files工具类的newByteChannel() 通道数据传输和内存映射文件 以下是四大文件操作对比： 通道（Channel）的数据传输(采用非直接缓冲区) 1234567891011121314151617181920212223242526@Testpublic void testChannel() throws IOException &#123; FileInputStream fileInputStream = new FileInputStream("Java NIO.pdf"); FileOutputStream fileOutputStream = new FileOutputStream("2.pdf"); // 1、获取通道 FileChannel inChannel = fileInputStream.getChannel(); FileChannel outChannel = fileOutputStream.getChannel(); // 2.分配指定大小的缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); // 3、将通道的数据读入缓冲区 while (inChannel.read(byteBuffer) != -1) &#123; byteBuffer.flip();// 切换缓冲区为读模式 // 4、把缓冲区的数据写入通道 outChannel.write(byteBuffer); byteBuffer.clear();// 因为需要循环多次读，需要清空缓冲区。 &#125; byteBuffer.clear(); inChannel.close(); outChannel.close(); fileInputStream.close(); fileOutputStream.close();&#125; 内存映射文件（采用直接缓冲区） 12345678910111213141516171819202122232425@Testpublic void testMemoryMappingFile() throws IOException &#123; long start = System.currentTimeMillis(); FileChannel inChannel = FileChannel.open(Paths.get("D:\\nio.zip"), StandardOpenOption.READ); // 注意：StandardOpenOption.CREATE // 如果文件已经存在，直接覆盖，StandardOpenOption.CREATE_NEW,如果文件已经存在，就抛出异常。 FileChannel outChannel = FileChannel.open(Paths.get("E:\\nio.zip"), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE); // 获取内存映射文件 MappedByteBuffer inMappedByteBuffer = inChannel.map(MapMode.READ_ONLY, 0, inChannel.size()); MappedByteBuffer outMappedByteBuffer = outChannel.map(MapMode.READ_WRITE, 0, inChannel.size()); // 直接对数据进行读写 byte[] bytes = new byte[inMappedByteBuffer.limit()]; // 此时，如果数据读超出了一定返回会抛出异常。如果内存不足时，会抛出java.lang.OutOfMemoryError: Java heap space inMappedByteBuffer.get(bytes); outMappedByteBuffer.put(bytes); inChannel.close(); outChannel.close(); long end = System.currentTimeMillis(); System.out.println((end - start));&#125; transferTo&amp;transferFrom将数据从源通道传输到其他 Channel 中(采用直接缓存区) 123456FileChannel inChannel = FileChannel.open(Paths.get("D:\\nio.zip"), StandardOpenOption.READ);// 注意：StandardOpenOption.CREATE// 如果文件已经存在，直接覆盖，StandardOpenOption.CREATE_NEW,如果文件已经存在，就抛出异常。FileChannel outChannel = FileChannel.open(Paths.get("E:\\nio.zip"), StandardOpenOption.READ,StandardOpenOption.WRITE, StandardOpenOption.CREATE);//inChannel.transferTo(0, inChannel.size(), outChannel);outChannel.transferFrom(inChannel, 0, inChannel.size()); 分散读取和聚集写入分散读取：将通道中的数据分散到多个缓冲区中 1234567//分配制定大小缓冲区ByteBuffer buffer1 = ByteBuffer.allocate(100);ByteBuffer buffer2 = ByteBuffer.allocate(1024);//分散读取ByteBuffer[] buffers = &#123;buffer1,buffer2&#125;; //通道里面进行读取channel.read(buffers); 聚集写入：将多个缓冲区中的数据集中到通道中123456789//写入完毕之后 for 循环for(ByteBuffer byteBuffer : buffers) &#123; //切换成读的模式 byteBuffer.flip();&#125;RandomAccessFile randomAccessFile = new RandomAccessFile("test2.txt", "rw");//获取通道FileChannel channel2 = randomAccessFile.getChannel();channel2.write(buffers); 字符集Charset在java.nio.charset包中共提供了Charset。向ByteBuffer中存放数据时需要考虑字符集的编码方式，从中读取时需要考虑字符集的解码。要读和写文本需要分别使用CharsetDecoder（解码器）和CharsetEncoder（编码器）。在JDK源码中提供如下静态方法得到一个CharSet实例： 1CharSet cs = CharSet.forName(“编码方式”); 得到一个CharSet实例后，我们需要创建一个编码器和一个解码器，使用下面方法进行创建： 123CharSetDecoder decoder = cs.newDecoder();CharSetEncoder encoder = cs.newEncoder(); 接着我们把ByteBuffer传递给decoder进行编码，返回一个CharBuffer： 1CharBuffer cb = decoder.decode(inputData); 然后我们可以使用encoder进行解码返回一个ByteBuffer： 1ByteBuffer outputData = encoder.encode(cb); 阻塞模式和非阻塞模式阻塞模式： 将直接使用accept()监听事件 非阻塞模式： 采用选择器，将通道注册到选择器上， 并指定监听接收事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** client *///1.获取通道SockectChannel schannel = SocketChannel.open(new InetSocketAddress("127.0.0.1",9898));//2.切换非阻塞模式schanne.configureBloking(false);//3.配置Buffer ...ByteBuffer buf = ByteBuffer.allocate(1024);//4.发送数据给服务器Scanner scan = new Scanner(System.in);while(scan.hasNext())&#123; String str = scan.next(); buf.put(str.getByte()); buf.flip(); schannel.write(buf); buf.clear();&#125;/** server *///1.通道获取ServerSocketChannel sschannel = ServerSocketChannel.open();//2.切换非阻塞模式sschannel.configureBloking(false);//3.绑定连接sschannel.bind(new InetSocketAdderss(9899));//4.获取选择器Selector selector = Serlector.open();//5.将通道注册到选择器上， 并指定监听接收事件sschannel.register(selector,SelectionKey.OP_ACCEPT);//6.轮询式的获取选择器上已经就绪的事件while(sockect.select() &gt; 0)&#123; //7.获取当前选择器中所有组测的选择键（已就绪的监听事件） Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator(); while(it.hasNext())&#123; //8.获取准备就绪事件 SelectionKey sk = it.next(); //9.判断具体就绪事件类型 if(sk.isAcceptable())&#123; //10.若接收就绪，获取客户端连接 SockectChannel schannel = schannel.accpet(); //11.切换非阻塞模式 schannel.configueBloking(false); //12.将通道注册到选择器 schannel.register(selector,SelectionKey.OP_READ); &#125;else if(sk.isReadable())&#123; //读事件处理 &#125; //移除 SelectionKey it.remove(); &#125;&#125;` 管道（pipe）Java NIO 管道式两个线程之间的单向数据连接。 Pipe 有一个source通道和一个sink通道，数据会被写到sink通道，从source通道读取。 12345678910111213//1.获取管道Pipe pipe = Pipe.open();//2.将缓冲区中的数据写入管道ByteBuffer buf = ByteBuffer.allocate(1024);Pipe.SinkChannel sinkChannel = pipe.sink();buf.put("通过担心管道发送数据".getBytes());buf.flip();int len = sourceChannel.read(buf);System.out.println(new String(buf.array(),0,len));sourceChannel.close();sinkChannel.close();]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>nio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[采用递归的形式做Java树状形式解析]]></title>
    <url>%2F2021%2F04%2F20%2Fjava%20EE%2Fjava%20%E4%BB%A3%E7%A0%81%E5%81%9A%E6%A0%91%E7%8A%B6%E5%BD%A2%E5%BC%8F%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[采用递归的形式做Java树状形式解析 1234567891011121314151617181920212223242526272829303132333435363738394041private List&lt;GpsStrategyVO&gt; recursionGetGpsStrategy(List&lt;GpsStrategy&gt; gpsStrategies,int parentId)&#123; List&lt;GpsStrategyVO&gt; next = new ArrayList&lt;&gt;(); //1.获取所有子集合 gpsStrategies.stream().forEach(gpsStrategyVO -&gt;&#123; if(parentId == gpsStrategyVO.getParentId())&#123; GpsStrategyVO strategyVO = new GpsStrategyVO(); BeanUtils.copyProperties(gpsStrategyVO,strategyVO); next.add(strategyVO); &#125; &#125;); //2.遍历子集合，给当前每一条数据插入子集合（递归） if (!ObjectIsNullUtil.isNullOrEmpty(next))&#123; next.stream().forEach(gpsStrategyVO -&gt; &#123; List&lt;GpsStrategyVO&gt; gpsStrategyVOS = recursionGetGpsStrategy(gpsStrategies, gpsStrategyVO.getStrategyId()); if (!ObjectIsNullUtil.isNullOrEmpty(gpsStrategyVOS))&#123; gpsStrategyVO.setNext(gpsStrategyVOS); &#125; //2.1 获取策略详情列表 if (null == gpsStrategyDetailVOList)&#123; getGpsStrategyDetailVOs(); &#125; //2.2 获取当前策略id对应的策略详情 gpsStrategyVO.setGpsStrategyDetails(gpsStrategyDetailService.selectStrategyDetailsByStrategyIdLogic(gpsStrategyDetailVOList,gpsStrategyVO.getStrategyId())); &#125;); &#125; return next; &#125; private static List&lt;GpsStrategyDetailVO&gt; gpsStrategyDetailVOList = null; /** * 初始化策略详情 * @return */ public List&lt;GpsStrategyDetailVO&gt; getGpsStrategyDetailVOs()&#123; if(gpsStrategyDetailVOList == null)&#123; gpsStrategyDetailVOList = gpsStrategyDetailService.selectAll(); &#125; return gpsStrategyDetailVOList; &#125; 场景 该场景是做一个树状结构的返回。其中，最高级别的parentId设置为0.则调用方法只需传入整个列表和0即可：1234//1.查询全部List&lt;GpsStrategy&gt; gpsStrategies = gpsStrategyService.selectAll();//2.递归List&lt;GpsStrategyVO&gt; strategies = recursionGetGpsStrategy(gpsStrategies, 0); 递归解释 先获取当前条件下所有子查询]]></content>
      <categories>
        <category>JAVA EE</category>
      </categories>
      <tags>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springBoot 使用@Value获取配置文件中参数]]></title>
    <url>%2F2021%2F04%2F20%2Fjava%20EE%2Fspring%2FspringBoot%20%E4%BD%BF%E7%94%A8%40Value%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[非静态变量赋值 直接使用@Value(&quot;${spring.redis.host}&quot;)配置，spring.redis.host为配置文件中参数命名，注意不要忘记加${}。 12345678910111213@RestController@RequestMapping("/jedis")public class JedisDemo1 &#123; @Value("$&#123;spring.redis.host&#125;") private String host; @RequestMapping(value ="/hellJedis") public String hellJedis() &#123; System.out.println("host:" + host ); return "hello host !!"; &#125;&#125; 静态变量赋值 使用@Component注解 在set方法上使用@Value12345678910111213@Componentpublic class Test &#123; private static Integer test; public static Integer getTest() &#123; return test; &#125; @Value("$&#123;server.port&#125;") public void setTest(Integer test) &#123; this.test = test; &#125;&#125; 参考文档：static静态变量使用@Value注入方式 题外话：初次使用，一定得考虑时静态变量和非静态变量。又一坑~~ 引入jar &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt;]]></content>
      <categories>
        <category>JAVA EE</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netty 基础]]></title>
    <url>%2F2021%2F04%2F20%2Fnetty%2FNetty%20%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[原生NIO存在的问题 类库繁杂 需要多线程知识 工作量增加，难度增加 会出现断连、重连、网络闪退、半包读写、失败缓冲、网络拥塞、和异常流的处理 NIO本身的bug Epoll bug Netty 概念 异步，基于事件驱动的网络应用框架，可快速开发高性能，高可靠性的网络应用 线程模型的基本介绍 传统阻塞I/O Reactor模式（反应式） 单Reactor,单线程 单Reactor，多线程 主从Reactor，多线程 netty 基于主从Reactor 多线程模型 传统阻塞型I/O模型 模型特点 采用阻塞IO模式获取输入的数据 每个连接都选用独立的线程完成数据输入 问题 并发数很大的情况下不适用 会阻塞]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springBoot 两种配置文件]]></title>
    <url>%2F2021%2F04%2F20%2Fjava%20EE%2Fspring%2FspringBoot%20%E4%B8%A4%E7%A7%8D%E6%A0%BC%E5%BC%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[springBoot 两种配置文件springBoot 有两种配置文件格式 .properties 默认格式（默认读取application.properties） 123server.port=8089server.context-path=/server.session.timeout=1200 .yml (yml格式采用缩进方式，在冒号后必须有空格，否则读取不到数据) 12345server: port: 8090 context-path: / session: timout: 1200 日常文件配置日常开发、部署、测试时候，我们经常需要替换配置文件，冗长复杂而且容易出错。现springBoot提供不同情况下配置文件切换。(此处拿yml格式做演示) 首先，我们知道springBoot默认读取的文件为application.yml,那么我们就在该文件配置切换，以下为具体： 123spring: profiles: active: prod 其次，prod 是一个以application为开头的配置文件，名称：application-prod.yml,因主配置文件里配置的为prod,则在启动项目时，默认加载该文件。 当然，我们也可以运用以上命名规则，创建多个配置文件，随意切换。 YAML和YML 维基百科关于YML的文章说“.yml”是“ YAML文件格式的文件扩展名”（强调增加了）。其YAML文章列出了两个扩展名，没有表示偏好。 YAML是一种直观的能够被电脑识别的的数据序列化格式，容易被人类阅读，并且容易和脚本语言交互。YAML类似于XML，但是语法比XML简单得多，对于转化成数组或可以hash的数据时是很简单有效的。 题外话：在springBoot项目下，点击右键新建.yml文件，即会自动转为spring模式。（之前搭建遇到的坑~~）]]></content>
      <categories>
        <category>JAVA EE</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想读书笔记--第九章 接口]]></title>
    <url>%2F2018%2F10%2F31%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2Fjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%2FJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[接口和内部类为我们提供了一种将接口与现实分离的更加结构化的方法 抽象类和抽象方法 抽象方法：用关键字abstract表示。如： 1public abstract void play(); 抽象类：是普通类和接口之间的中庸之道。同样用关键字abstract表示。 123456abstract class Instrument&#123; public abstract void play(); public void wind()&#123; //this is Common method &#125;&#125; abstract使用注意： 1.包含抽象方法的类必定是抽象类，抽象类不一定包含抽象方法（无意义） 2.当子类想通过继承的方式来使用父类（假设父类有抽象方法），那么它必须实现父类的抽象方法。如果不实现，那么它也只能是抽象类。并且继承父类的全部抽象方法。 3.abstract类里允许有普通方法。 作用： 它们可以使类的抽象性明确起来，并告诉用户和编译器打算怎么使用它们。 抽象类还是很有用的重构工具，它们使得我们可以很容易的将公共方法沿着继承层次结构向上移动。 接口 用interface这个关键字来产生一个完全抽象的类（没有普通方法） 123public interface Instrument&#123; public void play();&#125; 被用来建立类与类之间的协议 允许创建一个能够被向上转型为多种基类的类型，来实现某种类似多种继承变种的特性 要实现一个接口，需要用implements关键字。 123456public class InstrumentImpl implements Instrument&#123; @Override public void play()&#123; &#125;&#125; 接口也可以包含域，但是这些域隐式的是static和final的。 接口中的方法可以不声明访问级别（默认不写/finally），它们自动就是public的。 Java中的多重继承 Java是单继承模式，但是我们可以使用implements来实现多重继承（implements多个接口，用逗号相隔） 12345678910111213interface c&#123; void flight();&#125;interface c2&#123; void swim();&#125;class c3&#123; void fly()&#123;&#125;&#125;class Hero extends c3 implements c,c2&#123; void flight()&#123;&#125; void swim()&#123;&#125;&#125; 注意： 1.如果一个类同时需要extends和implements，需要将extends放在implements前面。 2.需要实现多个接口情况下，尽量避免不同接口的方法名相同。 使用接口的核心原因： 为了能够向上转型为多个基类型（以及由此带来灵活性） 防止客户端程序员创建该类的对象，并确保这仅仅是建立一个接口。 如果确认某个事物应该成为基类，那么首选接口。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven 基础知识]]></title>
    <url>%2F2018%2F10%2F20%2Fmaven%2Fmaven-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[mvn -v 查看maven版本 maven生命周期： clean 清理项目 pre-clean 执行清理前工作 clean 清理上一次构建生成的所有文件 post-clean 执行清理后的文件 default 构建项目 compile 编译 test 测试 package 打包 clean 删除目标文件 install 发布到本地仓库 site 生成项目站点 pre-site 在生成项目站点前要完成的功能 site 生成项目的站点文档 post-site 在生成项目站点后要完成的工作 site-deploy 发布生成的站点到服务器上 创建目录的两种方式： archetype:generate 按照提示进行选择 archetype:generate -DgroupId= 组织名。公司网址的反写+项目名 -DartifactId=项目名-模块名 -Dversion=版本号 -Dpackage=代码所存在的包名 pom文件解析 modelVersion 指定pom版本 groupId 主项目标识（公司网址的反写+项目名） artifactId 模块标识（项目名+模块名） version 当前项目版本号（0.0.1） 第一个标识大版本号 第二个表示分支版本号 第三个表示小版本号 snapshot快照 alpha内部测试 beta 公测 Relesae 稳定 GA正式发布 packaging 打包方式,默认是jar(war、zip、pom) name 项目描述名 url 项目地址 description项目描述 developers 开发人员列表 licenses 许可 organization 组织 dependencies 依赖列表 dependencie 依赖项 type scope 依赖范围 test 测试范围内有用 complile 默认范围，编译测试都有效 provided 测试编译 runtime 调用 system 测试编译（本地） import 只使用在dependencyManagement，表示从其他的pom中导入dependecy的配置 optional 设置依赖是否可选 exclusions 排除依赖传递列表 dependencyManagement 依赖管理 定义在父模块，供子模块继承 build 对构建行为提供相应的支持 plugins 插件列表 -plugin 插件 parent 子模块对父模块pom继承 modules 聚合运行多个项目]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想读书笔记--第八章 多态]]></title>
    <url>%2F2018%2F10%2F16%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2Fjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%2FJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态概述在面向对象的程序设计语言中，多态是继数据抽象和继承之后的第三种基本特征。 多态不但能够改善代码的组织结构和可读性，还能够创建可扩展的程序。 在多态允许我们无需管导出类（子类）的存在，编写的代码只是与基类（父类）打交道 多态别称：又叫动态绑定、后期绑定或运行时绑定 绑定：将一个方法调用与一个方法主体关联起来称作绑定 前期绑定：若在程序执行前进行绑定（如果有的话，由编译器和连接程序实现），叫做前期绑定。它是面向过程语言中不需要选择就默认的绑定方式。例如，C只有一种方法调用，那就是前期绑定。 后期绑定：就是在运行时根据对象的类型进行绑定。后期绑定也叫做动态绑定或运行时绑定。如果一种语言想实现后期绑定，就必须具有某种机制，以便在运行时能判断对象的类型，从而调用恰当的方法。也就是说，编译器一直不知道对象的类型，但是方法调用机制能找到正确的方法体，并加以调用。后期绑定机制随编程语言的不同而有所不同，但是只要想一下就会得知，不管怎样都必须在对象中安置某种“类型信息”。再论final 可以防止其他人覆盖该方法 还可以有效的”关闭”动态绑定 private(隐形final)不可被覆盖 论static 如果某个方法是静态的，它的行为就不具有多态性 静态方法是与类，而非与单个的对象相关联的。 static不可以被重写，但可以被重载 构造器 构造器（隐式static），同样不具有多态性 构造器特殊任务：检查对象是否被正确的构造 对象调用构造器遵从顺序： 调用基类构造器，这个步骤或不断的反复递归下去，首先是构造这种层次结构的根，然后是下一层导出类，直到最底层的导出来 按照声明顺序调用成员的初始化方法 调用导出类构造器的主体 构造器内部的多态方法的行为如果在一个构造器的内部调用正在构造的对象的某个动态绑定方法，那么会发生什么情况呢？12345678910111213141516171819202122232425262728293031323334353637/** * 构造器内部的多态方法的行为 */public class PolyConstructors &#123; public static void main(String[] args) &#123; new RoundGlyph(5); &#125;&#125;class Glyph&#123; void draw()&#123; System.out.println("Glyph.draw()"); &#125; public Glyph() &#123; System.out.println("Glyph() before draw()"); draw(); System.out.println("Glyph() after draw()"); &#125;&#125;class RoundGlyph extends Glyph&#123; private int radius = 1; public RoundGlyph(int radius) &#123; this.radius = radius; System.out.println("RoundGlyph.RoundGlyph(),radius="+radius); &#125; void draw()&#123; System.out.println("RoundGlyph.draw(),radius="+radius); &#125;&#125;/*Output:Glyph() before draw()RoundGlyph.draw(),radius=0Glyph() after draw()RoundGlyph.RoundGlyph(),radius=5*///:~ 由上可以看出，在打印radius时，不是我们默认初始化的1，而是0。违背了我们的初衷。我们要用尽可能简单的方法使对象进入正常状态；如果可以的话，避免调用其他方法。 初始化的实际过程是： - 在其他任何事物发生之前，将分配给对象的存储空间初始化成二进制的零 - 如前所述的那样调用及剋构造器。 - 按照声明的顺序调用成员的初始化方法 - 调用导出类的构造主体]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想读书笔记--第七章 复用类]]></title>
    <url>%2F2018%2F10%2F11%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2Fjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%2FJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%A4%8D%E7%94%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[复用类是什么？ 众所周知，面向对象的其中一个特性就是继承，也就是我们今天所说的复用类的一种。我们一般将其运用在，需要使用一段旧的代码，但又需要对其进行部分修改。 这个时候，我们选择复用类，可以通过创建新类来复用代码,更大程度上使原代码不被破坏。 复用类目前包含 组合 继承 代理 组合组合技术简单来说，就是将对象引用于新类中即可。12345678910111213141516171819202122232425262728/** * 组合 */public class ShowCombination &#123; public void combination()&#123; //doSomething System.out.println("ShowCombination"); &#125;&#125;class UseCombination&#123; public void use()&#123; ShowCombination showCombination = new ShowCombination(); showCombination.combination(); //doSomething System.out.println("UseCombination"); &#125; public static void main(String[] args) &#123; UseCombination useCombination = new UseCombination(); useCombination.use(); &#125;&#125;/* Output:ShowCombinationUseCombination *///:~` 那么，我们是否可以理解为组合就是创建一个新类去调用已经创建并且调试好的类（在新类里实例化之前的类）？ 继承我们使用extends关键字去实现类复用。这里的ShowExtends被我们称作基类（父类）12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 继承 */public class ShowExtends &#123; public ShowExtends() &#123; System.out.println("this is ShowExtends construction "); &#125; public void extendsMethod()&#123; //doSomething System.out.println("ShowExtends"); &#125;&#125;class UseExtends extends ShowExtends&#123; public UseExtends() &#123; System.out.println("this is UseExtends construction "); &#125; @Override public void extendsMethod() &#123; super.extendsMethod(); //doSomething System.out.println("UseExtends"); &#125; public void otherMethod()&#123; System.out.println("this is new method"); &#125; public static void main(String[] args) &#123; UseExtends useExtends = new UseExtends(); useExtends.extendsMethod(); useExtends.otherMethod(); &#125;&#125;/* Output:this is ShowExtends construction this is UseExtends construction ShowExtendsUseExtendsthis is new method *///:~ 如上代码所看到的，我们在子类使用extends继承父类，这个时候，我们可以使用父类的方法；同时，也可以重写父类的方法或新写一个方法。 注意： 1. 我们在继承父类的时候，父类的方法是不可用private去修饰的。 2. 一般，我们将保密程度较强，但是子类需要的方法定义为protected。 3. super.extendsMethod()， 我们尝试注释掉该句话，将不会执行父类的方法; 4. 在继承中，初始化的顺序是从父类-&gt;子类（先初始化父类构造方法，再初始子类构造方法，再进行下边的方法调用；这个时候，即使注释掉super.extendsMethod()， 父类构造方法依然会被初始化）。 5.@Override Java SE5 新增注解，用于想要复写某个方法时，在方法上加以注解。 代理java并没有提供对代理的直接支持，代理是继承与组合之间的中庸之道。我们使用代理可以拥有更多的控制力，因为我们可以选择只提供在成员对象中的方法的某个子集。123456789101112131415/** * 代理 */public class ShowAgent &#123; void firstMethod()&#123;&#125; void secondMethod()&#123;&#125; void thirdMethod()&#123;&#125;&#125;class UserAgent&#123; private ShowAgent showAgent = new ShowAgent(); public void secondMethod()&#123; showAgent.secondMethod(); &#125;&#125; 向上转型 向上转型：就继承来说，新类可以拥有现有类所有方法，同时可以增加自己新的方法。那我们可以概括为“新类是现有类的一种类型”。 1234567891011121314151617/** * 向上转型 */class Instrument&#123; public void play ()&#123;&#125; static void tune(Instrument i)&#123; //... i.play(); &#125;&#125;public class Wind extends Instrument&#123; public static void main(String[] args) &#123; Wind flute = new Wind(); Instrument.tune(flute); //Upcasting &#125;&#125; 在组合和继承之间选择 组合技术通常用于想在新类中使用现有类的功能而非它的接口这种情形。即在新类中嵌入某个对象，让其实现所需要的功能，但是新类的用户看到的只是为新类所定义的接口，而非所嵌入对象的接口。（为去得此效果，需要在新类中嵌入一个现有类的private对象） 在继承的时候，使用某个现有的类，并开发一个它的特殊版本。通常，这意味着你在使用一个通用类，并为了某个特殊需要而将其特殊化。 选择：判断自己是否需要从新类向基类进行向上转型。如果必须向上转型，则使用继承。否则，则选择组合或者代理。 final 关键字 final是恒定不变的？ final 对于基本数据类型是恒定不变的。 但是对于引用型数据类型，则是使引用恒定不变，而被引用的对象本身使可以改变的。 static :不可变的，静态的，不会随着对象的创建而变化 将final数值定义为静态和非静态的区别： 可以看出i1是随着初始化的变化而变化 i2则是固定不变的，这是因为i2是static的，在装载时已被初始化，而不是每次创建新对象时都会初始化。（定义为static的东西只会被初始化一次） 12345678910111213141516171819202122232425/** * 将final数值定义为静态和非静态的区别 */public class FinalWithStatic &#123; private static Random rand = new Random(7); private final int i1 = rand.nextInt(20); static final int i2 = rand.nextInt(20); @Override public String toString() &#123; return "FinalWithStatic&#123;" + "i1=" + i1 +";i2=" + i2 + '&#125;'; &#125; public static void main(String[] args) &#123; FinalWithStatic fs1 = new FinalWithStatic(); FinalWithStatic fs2 = new FinalWithStatic(); System.out.println(fs1); System.out.println(fs2); &#125;&#125;/*Output:FinalWithStatic&#123;i1=4;i2=16&#125;FinalWithStatic&#123;i1=5;i2=16&#125;*///:~ 必须在域的定义处或者每个构造器中用表达式对final进行赋值，这正是final域在使用前总是被初始化的原因所在。 使用final方法原因： 将方法锁定，以防止任何继承类修改它的含义。 效率 （考虑：所带来的性能提高会因为花费于方法内的时间量而被缩减） 只有在想要明确禁止覆盖时，方可将方法设置为final的 final 类： 当将某个类的整体定义为final时，就表示你不需要该类做任何变动和被其他类继承。 由于final类禁止继承，所以final类中所有的方法都隐式指定为是final的，因为它们无法被覆盖。 初始化及类的加载 包含static的初始化加载顺序 先加载static 之后加载构造方法 之后加载被调用的类 包含继承和static的初始化加载 先加载父类static 再加载子类static 之后加载父类构造方法 再加载子类构造方法 之后再加载被调用的类 总结 组合一般是将现有类型作为新类型底层实现的一部分来加以复用 继承复用的是接口 一般优先选择组合或者代理，只有确认必要时才使用继承]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--备忘录模式]]></title>
    <url>%2F2018%2F10%2F07%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[场景 录入大批人员资料。正在录入当前人资料时，发现上一个人录错了。此时需要恢复上一个人的资料，在进行修改。 Word文档编辑时，忽然电脑死机或者断电，再次打开时，可以恢复到之前的模式。 核心 就是保存某个对象内部状态的拷贝，这样以后就可以将该对象恢复至原先的状态 结构 源发器类 Originator 备忘录类Memento 负责人类CareTake 代码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138/** * 源发器类 */public class Emp &#123; private String ename; private int age; private double salary; //进行备忘操作，并返回备忘录对象 public EmpMemento memento()&#123; return new EmpMemento(this); &#125; //数据恢复,恢复成指定备忘录值 public void recovery(EmpMemento memento)&#123; this.ename = memento.getEname(); this.age = memento.getAge(); this.salary = memento.getSalary(); &#125; public Emp(String ename, int age, double salary) &#123; this.ename = ename; this.age = age; this.salary = salary; &#125; public String getEname() &#123; return ename; &#125; public void setEname(String ename) &#123; this.ename = ename; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125;&#125;/** * 备忘录类 */public class EmpMemento &#123; private String ename; private int age; private double salary; public EmpMemento(Emp e) &#123; this.ename = e.getEname(); this.age = e.getAge(); this.salary = e.getSalary(); &#125; public String getEname() &#123; return ename; &#125; public void setEname(String ename) &#123; this.ename = ename; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125;&#125;/** * 负责人类 * 负责管理备忘录对象 */public class CareTaker &#123; private EmpMemento memento; //此处可以存放list，保存多个点 //private List&lt;EmpMemento&gt; list = new ArrayList&lt;&gt;(); public EmpMemento getMemento() &#123; return memento; &#125; public void setMemento(EmpMemento memento) &#123; this.memento = memento; &#125;&#125;/** * 备忘录模式 */public class Client &#123; public static void main(String[] args) &#123; CareTaker taker = new CareTaker(); Emp emp = new Emp("kid",18,900); System.out.println("第一次打印对象："+emp.getEname()+"===="+emp.getAge()+"==="+emp.getSalary()); //备忘一次 taker.setMemento(emp.memento()); emp.setAge(28); emp.setEname("六六"); emp.setSalary(2910); System.out.println("第二次打印对象："+emp.getEname()+"===="+emp.getAge()+"==="+emp.getSalary()); //恢复到备忘录对象保存的状态 emp.recovery(taker.getMemento()); System.out.println("第三次打印对象："+emp.getEname()+"===="+emp.getAge()+"==="+emp.getSalary()); &#125;&#125; 结果： 第一次打印对象：kid====18===900.0 第二次打印对象：六六====28===2910.0 第三次打印对象：kid====18===900.0 备忘点较多时： 将备忘录存为List 将备忘录压栈 将多个备忘录对象，序列化和持久化 开发中常见的应用场景 棋类游戏中，悔棋 普通软件中的，撤销操作 数据库软件中，事务管理中，回滚操作 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--观察者模式]]></title>
    <url>%2F2018%2F09%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[场景 聊天室程序的创建。服务器创建好后，A,B,C三个客户端连上来公开聊天。A向服务器发送数据，服务器端聊天数据改变。我们希望将这些聊天数据分别发给其他的在线的客户。也就是说，每个客户端需要更新服务器端的数据 上面这个场景，我们都可以使用观察者模式来处理。我们可以把多个订阅者/客户称之为观察者，需要同步给多个订阅者的数据封装到对象中，称之为目标。 核心 观察者模式主要用于1：N的通知。当一个对象（目标对象Subject或Objservable）的状态变化时，他需要及时告知一系列对象（观察者对象，Observer），令他们做出响应 通知观察者的模式： 推 每次都会把通知以广播方式发送给所有观察者，所有观察者只能被动接收 拉 观察者只要知道有情况即可。至于什么时候获取内容，获取什么内容，都可以自主决定。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * 观察者对象 接口 */public interface Observer &#123; void update(Subject sub);&#125;/** * 主题对象（目标对象） */public class Subject &#123; protected List&lt;Observer&gt; list = new ArrayList&lt;Observer&gt;(); public void registerObserver(Observer observer)&#123; list.add(observer); &#125; public void removeObserver(Observer observer)&#123; list.remove(observer); &#125; /** * 通知所有观察者更新状态 */ public void notifyAllObservers()&#123; for (Observer obs : list) &#123; obs.update(this); &#125; &#125;&#125;/** * 具体目标对象状态子类 */public class ConcreteSubject extends Subject &#123; private int state; public int getState() &#123; return state; &#125; public void setState(int state) &#123; this.state = state; //目标对象值发生变化，请通知所有观察者 this.notifyAllObservers(); &#125;&#125;/** * 具体的观察者 */public class ObserverA implements Observer&#123; private int myState; // 需要和目标对象状态保持一致 @Override public void update(Subject sub) &#123; myState = ((ConcreteSubject)sub).getState(); &#125; public int getMyState() &#123; return myState; &#125; public void setMyState(int myState) &#123; this.myState = myState; &#125;&#125;/** * 观察者模式 */public class Client &#123; public static void main(String[] args) &#123; //目标对象 ConcreteSubject subject = new ConcreteSubject(); //创建多个观察者 ObserverA obs1 = new ObserverA(); ObserverA obs2 = new ObserverA(); ObserverA obs3 = new ObserverA(); //将这三个观察者添加到subject对象的观察者队伍中 subject.registerObserver(obs1); subject.registerObserver(obs2); subject.registerObserver(obs3); //改变subject的状态 subject.setState(3000); System.out.println("######################"); System.out.println(obs1.getMyState()); System.out.println(obs2.getMyState()); System.out.println(obs3.getMyState()); //改变subject的状态 subject.setState(30); System.out.println("######################"); System.out.println(obs1.getMyState()); System.out.println(obs2.getMyState()); System.out.println(obs3.getMyState()); &#125;&#125; 结果： ###################### 3000 3000 3000 ###################### 30 30 30 JAVASE提供了java.util.Observable和java.util.Observer来实现观察者模式 开发中常见的场景 聊天室程序的，服务器转发给所有的客户端 网络游戏（多人联机对账）场景中，服务器将客户端的状态进行分发 邮件订阅 Servlet中，监听器的实现 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--状态模式]]></title>
    <url>%2F2018%2F09%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[场景 电梯的运行 维修、正常、自动关门、自动开门、向上运行、向下运行、消防状态 红绿灯 红灯、黄灯、绿灯 企业或政府系统 公文的审批状态 报销单据审批状态 假条审批 网上购物，订单的状态 酒店系统中，房间的状态变化： 已预定 已入住 空闲 核心 用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题 结构 Context环境类 环境类中维护一个State对象，他是定义了当前的状态 State抽象状态类 ConcreteState具体状态类 每一个类封装了一个状态对应的行为 不使用设计模式解决 代码解析（酒店系统模型）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 抽象状态类 */public interface State &#123; void handle();&#125;/** * 房间空闲 */public class FreeState implements State&#123; @Override public void handle() &#123; System.out.println("房间空闲，没人住"); &#125;&#125;/** * 已入住 */public class CheckedInState implements State&#123; @Override public void handle() &#123; System.out.println("房间已入住"); &#125;&#125;/** * 已预定 */public class BookedState implements State&#123; @Override public void handle() &#123; System.out.println("房间已预定"); &#125;&#125;/** * 环境类 */public class Context &#123; private State state; public void setState(State state) &#123; System.out.println("修改状态"); this.state = state; state.handle(); &#125;&#125;/** * 状态模式 */public class Client &#123; public static void main(String[] args) &#123; Context ctx = new Context(); ctx.setState(new FreeState()); &#125;&#125; 开发中常见的场景 银行系统中账号状态的管理 OA系统中公文状态的管理 酒店系统中，房间状态的管理 线程对象各个状态之间的切换 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--模板方法模式]]></title>
    <url>%2F2018%2F09%2F18%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[场景 客户到银行办理业务： 取号排队 办理具体现金/转账/企业/个人/理财业务 给银行工作人员评分 模板方法模式介绍 模板方法模式是编程中经常用到的模式。它定义了一个操作中的算法骨架，将某些步骤延迟到子类中实现。这样，新的子类可以在不改变一个算法结构的前提下重新定义该算法的某些特定步骤。 核心 处理某个流程的代码已经都具备，但是其中某个节点的代码暂时不能确定。因此，我们采用工厂方法模式，将这个节点的代码实现转移给子类完成。即：处理步骤父类中定义好，具体实现延迟到子类中定义 代码实现（银行办理业务）模板方法12345678910111213141516171819202122public abstract class BankTeplateMethod &#123; public void takeNumber()&#123; System.out.println("排队取号"); &#125; public abstract void transact(); //办理具体的业务 //钩子方法 public void evaluate()&#123; System.out.println("反馈评分"); &#125; /** * 模板方法 */ public final void process()&#123; this.takeNumber(); this.transact(); this.evaluate(); &#125;&#125; 实现取款业务12345678910/** * 取款业务 */class DrawMoney extends BankTeplateMethod&#123; @Override public void transact() &#123; System.out.println("我要取款!!!"); &#125;&#125; 调用12345678910111213141516171819/** * 模板方法 */public class Client &#123; public static void main(String[] args) &#123; BankTeplateMethod btm = new DrawMoney(); btm.process(); //采用匿名内部类 BankTeplateMethod btm2 = new BankTeplateMethod() &#123; @Override public void transact() &#123; System.out.println("我要存钱！！！"); &#125; &#125;; btm2.process(); &#125;&#125; 什么时候用到模板方法模式 实现一个算法时，整体的步骤很固定。但是，某些部分易变。易变部分可以抽象出来，供子类实现 开发中常见的场景 数据库访问的分装 Junit单元测试 servlet中关于doGet/doPost方法的调用 Hibernate中模板程序 spring中JDBCTemplate、HibTemplate等。 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--策略模式]]></title>
    <url>%2F2018%2F09%2F12%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[场景 某个市场人员接到单后的报价策略（CRM系统中常见问题）。报价策略很复杂，可以简单作如下分类： 普通客户小批量报价 普通客户大批量报价 老客户小批量报价 老客户大批量报价 具体选用哪个报价策略，这需要根据实际情况来确定。这时候，我们采用策略模式即可。 普通代码实现 缺点：如果类型特别多，算法比较复杂时，整个条件控制代码会变得很长，难于维护 策略模式 策略模式对应于解决某个问题的一个算法族，允许用户从该算法族中任选一个算法解决某一问题，同时可以方便的更换算法或者增加新的算法。并且由客户端解决调用哪个算法。 代码解析通过策略模式实现以上场景 接口123public interface Strategy &#123; public double getPrice(double standarPrice);&#125; 具体算法包12345678910111213141516171819202122232425262728293031323334353637383940/** * 普通客户小批量 */public class NewCustomerFewStrategy implements Strategy&#123; @Override public double getPrice(double standarPrice) &#123; System.out.println("不打折，原价"); return standarPrice; &#125;&#125;/** * 普通客户大批量 */public class NewCustomerManyStrategy implements Strategy&#123; @Override public double getPrice(double standarPrice) &#123; System.out.println("打9折"); return standarPrice*0.9; &#125;&#125;/** * 老客户小批量 */public class OldCustomerFewStrategy implements Strategy&#123; @Override public double getPrice(double standarPrice) &#123; System.out.println("打8.5折"); return standarPrice*0.85; &#125;&#125;/** * 老客户大批量 */public class OldCustomerManyStrategy implements Strategy&#123; @Override public double getPrice(double standarPrice) &#123; System.out.println("打8折"); return standarPrice*0.8; &#125;&#125; 上下文类123456789101112131415161718192021222324/** * 上下文类 * 负责和具体的策略交互 */public class Context &#123; private Strategy strategy; //当前采用算法 public Context() &#123; &#125; //可以通过构造器注入 public Context(Strategy strategy) &#123; this.strategy = strategy; &#125; //可以通过set方法注入 public void setStrategy(Strategy strategy) &#123; this.strategy = strategy; &#125; public void printPrice(double s)&#123; System.out.println("您该报价："+strategy.getPrice(s)); &#125;&#125; 调用123456789101112/** * 策略模式 */public class Client &#123; public static void main(String[] args) &#123; //老客户 Strategy s1 = new OldCustomerManyStrategy(); Context context = new Context(s1); context.printPrice(998); &#125;&#125; 本质 分离算法，选择实现 开发中常见的场景 JAVASE中GUI编程中，布局管理 Spring框架中，Resource接口，资源访问策略 javax.servlet.http.HttpServlet#service() 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--访问者模式]]></title>
    <url>%2F2018%2F09%2F11%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模式动机 对于存储在一个集合中的对象，他们可能具有不同的类型（即使有一个公共的接口），对于该集合中的对象，可以接受一类称为访问者的对象来访问，不同的访问者其访问的方式也有所不同。 定义 表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变个元素的类的前提下定义作用于这些元素的新操作 开发中的场景（应用范围非常窄，了解即可） XML文档解析器设计 编译器的设计 复杂集合对象的处理 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--解释器模式]]></title>
    <url>%2F2018%2F09%2F11%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 是一种不常用的设计模式 用于描述如何构成一个简单的语言解释器，主要用于使用面向对象语言开发的编译器和解释器设计 当我们需要开发一种新的语言时，可以考虑使用解释器模式 尽量不要使用解释器模式，后期维护会有很大的麻烦。在项目中，可以使用Jruby,Groovy,java的js引擎来替代解释器的作用，弥补Java语言的不足 开发中常见的场景 EL表达式的处理 正则表达式解析器 sql语法的解析器 数学表达式的解析器 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--命令模式]]></title>
    <url>%2F2018%2F09%2F10%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。也称之为：动作Action、事务transaction模式 结构 Command抽象命令类 ConcreteCommand具体命令类 Invoker 调用者/请求者 请求的发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联。在程序运行时，将调用命令的execute(),间接调用接收者的相关操作。 Receiver接收者 接收者执行与请求相关的操作，具体实现对请求的业务处理。 未抽象前，实际执行操作内容的对象 Client客户类 在客户类中需要创建调用者对象、具体命令类对象，在创建具体命令对象时指定对应的接收者。发送者和接收者之间没有直接关系，都通过命令对象间接调用。 代码解析Receiver接收者12345678/** * 正真的执行者 （战士） */public class Receiver&#123; public void action()&#123; System.out.println("Receiver.action"); &#125;&#125; 抽象命令类和具体命令类12345678910111213141516171819202122232425262728/** * 抽象命令类 */public interface Command &#123; /** * 这个方法时一个返回结果为空的方法 * 实际项目中，可以根据需求设计多个不同的方法 */ void execute();&#125;/** * 具体命令类 */class ConcreteCommand implements Command&#123; private Receiver receiver; //命令的正在执行者 public ConcreteCommand(Receiver receiver) &#123; this.receiver = receiver; &#125; @Override public void execute() &#123; //命令执行前或后，执行相关的处理 receiver.action(); &#125;&#125; Invoker 调用者/请求者1234567891011121314151617/** * 命令的调用者/发起者（领导） */public class Invoke &#123; private Command command; //也可以通过同情List&lt;command&gt;容纳横队命令对象，进行批处理 public Invoke(Command command) &#123; this.command = command; &#125; /** * 业务方法，用于调用命令类的方法 */ public void call()&#123; command.execute(); &#125;&#125; Client客户类123456789101112/** * 命令模式 */public class Client &#123; public static void main(String[] args) &#123; Command c = new ConcreteCommand(new Receiver()); Invoke i = new Invoke(c); i.call(); new Receiver().action(); &#125;&#125; 开发中常见的场景 Struts2中，action的调用过程中就有命令模式 数据库事务机制的底层实现 命令的撤销和恢复（和备忘录模式整合用） 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--中介模式]]></title>
    <url>%2F2018%2F09%2F09%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[场景 在实际的公司运营中，都有一个总经理来协调管理各个部门。那么这里的总经理起到中介、协调的作用。这是一个典型的中介者模式 核心 如果一个系统中对象之间的联系呈现为网状结构，对象之间存在大量 多对多关系，将导致关系及其复杂，这些对象称之为同事对象 我们可以引用一个中介者对象，使各个同时对象只跟中介者对象打交道，将复杂的网络结构化解为星形结构 结构图 代码解析我们通过模拟公司日常运营中，总经理和各个部门之间处理事情场景，来用代码实现中介者模式 定义同事类（部门接口和具体部门）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * 同事类接口 */public interface Department &#123; /** * 做本部门的事情 */ void selfAction(); /** * 向总经理发出申请 */ void outAction();&#125;/** * 研发部 */public class Development implements Department &#123; private Mediator m; //持有中介者（总经理）的引用 public Development(Mediator m) &#123; super(); this.m = m; //当前部门注册到中介者中 m.register("development",this); &#125; @Override public void outAction() &#123; System.out.println("汇报工作！没钱了，需要资金支持！"); &#125; @Override public void selfAction() &#123; System.out.println("专心科研，开发项目！"); &#125;&#125;/** * 财务部 */public class Finacial implements Department &#123; private Mediator m; //持有中介者（总经理）的引用 public Finacial(Mediator m) &#123; super(); this.m = m; //当前部门注册到中介者中 m.register("finacial",this); &#125; @Override public void outAction() &#123; System.out.println("汇报工作！钱太多了，怎么花！"); &#125; @Override public void selfAction() &#123; System.out.println("数钱！"); &#125;&#125;/** * 市场部 */public class Market implements Department &#123; private Mediator m; //持有中介者（总经理）的引用 public Market(Mediator m) &#123; super(); this.m = m; //当前部门注册到中介者中 m.register("market",this); &#125; @Override public void outAction() &#123; System.out.println("汇报工作！项目承接的进度，需要资金支持！"); //调用财务部 m.command("finacial"); &#125; @Override public void selfAction() &#123; System.out.println("跑项目！"); &#125;&#125; 中介者（总经理接口和具体实现）1234567891011121314151617181920212223242526272829303132333435/** *中介者 */public interface Mediator &#123; /** * * @param dname 部门名称 * @param department 同事类 */ void register(String dname,Department department); /** * 发出命令 * @param dname */ void command(String dname);&#125;/** * 总经理 */public class President implements Mediator&#123; private Map&lt;String,Department&gt; map = new HashMap&lt;&gt;(); @Override public void register(String dname, Department department) &#123; map.put(dname,department); &#125; @Override public void command(String dname) &#123; map.get(dname).selfAction(); &#125;&#125; 调用123456789101112public class Client &#123; public static void main(String[] args) &#123; Mediator m = new President(); Market market = new Market(m); Development department = new Development(m); Finacial finacial = new Finacial(m); market.selfAction(); market.outAction(); &#125;&#125; 结果： 跑项目！ 汇报工作！项目承接的进度，需要资金支持！ 数钱！ 中介者模式的本质 解耦多个同事对象之间的交互关系。每个对象都持有中介者对象的引用，只跟中介者对象打交道。我们通过中介者对象统一管理这些交互关系 开发中常见的场景： MVC模式（其中的C，控制器就是一个中介者对象。M和V都和他打交道） 窗口游戏程序，窗口软件开发中窗口对象也是一个中介者对象 图形界面开发GUI中，多个组件之间的交互，可以通过引入一个中介者对象来解决，可以使整体的窗口对象或者DOM对象 java.lang.reflect.Method#invoke() 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[触发器 -- mysql触发器]]></title>
    <url>%2F2018%2F09%2F07%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E8%A7%A6%E5%8F%91%E5%99%A8-mysql%E8%A7%A6%E5%8F%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[mysql 触发器创建触发器在MySQL中，创建触发器语法如下： 代码如下: 123456CREATE TRIGGER trigger_nametrigger_timetrigger_event ON tbl_nameFOR EACH ROWtrigger_stmt 其中： trigger_name：标识触发器名称，用户自行指定； trigger_time：标识触发时机，取值为 BEFORE 或 AFTER； trigger_event：标识触发事件，取值为 INSERT、UPDATE 或 DELETE； tbl_name：标识建立触发器的表名，即在哪张表上建立触发器； trigger_stmt：触发器程序体，可以是一句SQL语句，或者用 BEGIN 和 END 包含的多条语句。 由此可见，可以建立6种触发器，即：BEFORE INSERT、BEFORE UPDATE、BEFORE DELETE、AFTER INSERT、AFTER UPDATE、AFTER DELETE。 另外有一个限制是不能同时在一个表上建立2个相同类型的触发器，因此在一个表上最多建立6个触发器。 实例根据实际项目需求，模拟一个表中的其中一个字段变化，在另一个表中添加一个对应的记录. 创建表test1 1234567CREATE TABLE `test1` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `pwd` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8; 创建表test2 1234567CREATE TABLE `test2` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `asd` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=61 DEFAULT CHARSET=utf8; 创建名字为test_name的触发器，当表test1中的pwd字段变为222的时候，会触发触发器在test2表中，插入一条数据；（old，new为关键字） 123456789DELIMITER $CREATE TRIGGER test_name AFTER UPDATE ON test1 FOR EACH ROWBEGINIF new.pwd = '222' THEN INSERT INTO test2 (name) SELECT name from test1 where id = old.id;END IF; END $DELIMITER ; 附录BEGIN … END 详解在MySQL中，BEGIN … END 语句的语法为： BEGIN[statement_list]END其中，statement_list 代表一个或多个语句的列表，列表内的每条语句都必须用分号（;）来结尾。而在MySQL中，分号是语句结束的标识符，遇到分号表示该段语句已经结束，MySQL可以开始执行了。因此，解释器遇到statement_list 中的分号后就开始执行，然后会报出错误，因为没有找到和 BEGIN 匹配的 END。 这时就会用到 DELIMITER 命令（DELIMITER 是定界符，分隔符的意思），它是一条命令，不需要语句结束标识，语法为：DELIMITER new_delemiternew_delemiter 可以设为1个或多个长度的符号，默认的是分号（;），我们可以把它修改为其他符号，如$：DELIMITER $在这之后的语句，以分号结束，解释器不会有什么反应，只有遇到了$，才认为是语句结束。注意，使用完之后，我们还应该记得把它给修改回来。 变量详解MySQL 中使用 DECLARE 来定义一局部变量，该变量只能在 BEGIN … END 复合语句中使用，并且应该定义在复合语句的开头， 即其它语句之前，语法如下： DECLARE var_name[,…] type [DEFAULT value]其中：var_name 为变量名称，同 SQL 语句一样，变量名不区分大小写；type 为 MySQL 支持的任何数据类型；可以同时定义多个同类型的变量，用逗号隔开；变量初始值为 NULL，如果需要，可以使用 DEFAULT 子句提供默认值，值可以被指定为一个表达式。 对变量赋值采用 SET 语句，语法为： SET var_name = expr [,var_name = expr] … NEW 与 OLD 详解上述示例中使用了NEW关键字，和 MS SQL Server 中的 INSERTED 和 DELETED 类似，MySQL 中定义了 NEW 和 OLD，用来表示 触发器的所在表中，触发了触发器的那一行数据。具体地：在 INSERT 型触发器中，NEW 用来表示将要（BEFORE）或已经（AFTER）插入的新数据；在 UPDATE 型触发器中，OLD 用来表示将要或已经被修改的原数据，NEW 用来表示将要或已经修改为的新数据；在 DELETE 型触发器中，OLD 用来表示将要或已经被删除的原数据；使用方法： NEW.columnName （columnName 为相应数据表某一列名）另外，OLD 是只读的，而 NEW 则可以在触发器中使用 SET 赋值，这样不会再次触发触发器，造成循环调用（如每插入一个学生前，都在其学号前加“2013”）。 查看触发器和查看数据库（show databases;）查看表格（show tables;）一样，查看触发器的语法如下： SHOW TRIGGERS [FROM schema_name];其中，schema_name 即 Schema 的名称，在 MySQL 中 Schema 和 Database 是一样的，也就是说，可以指定数据库名，这样就 不必先“USE database_name;”了。 删除触发器和删除数据库、删除表格一样，删除触发器的语法如下： DROP TRIGGER [IF EXISTS] [schema_name.]trigger_name 触发器的执行顺序我们建立的数据库一般都是 InnoDB 数据库，其上建立的表是事务性表，也就是事务安全的。这时，若SQL语句或触发器执行失败，MySQL 会回滚事务，有： ①如果 BEFORE 触发器执行失败，SQL 无法正确执行。 ②SQL 执行失败时，AFTER 型触发器不会触发。 ③AFTER 类型的触发器执行失败，SQL 会回滚 本文大部分内容选自：MySQL触发器使用详解]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--迭代器模式]]></title>
    <url>%2F2018%2F09%2F07%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[场景 提供一种可以遍历聚合对象的方式。又称为游标cursor模式 聚合对象：存储数据 迭代器：遍历数据 代码解析12345678910111213/** * 迭代器接口 */public interface MyIterator &#123; void first(); //将游标指向第一个元素 void next(); //将游标指向下一个元素 boolean hasNext(); //判断是否存在下一个元素 boolean isFirst(); boolean isLast(); Object getCurrentObj(); //获取当前游标指向对象&#125; 定义内部聚合类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 自定义的聚合类 */public class ConcrtetMyAggregate &#123; private List&lt;Object&gt; list = new ArrayList&lt;&gt;(); public ConcrtetMyAggregate() &#123; &#125; public void addObject(Object object)&#123; this.list.add(object); &#125; public void removeObject(Object obj)&#123; this.list.remove(obj); &#125; public List&lt;Object&gt; getList()&#123; return list; &#125; public void setList(List&lt;Object&gt; list)&#123; this.list = list; &#125; public MyIterator createIterator()&#123; return new ConcreteIterator(); &#125; //使用内部类定义迭代器，可以直接使用外部类的属性 private class ConcreteIterator implements MyIterator&#123; private int cursor; //定义游标用于记录遍历时的位置 @Override public void first() &#123; cursor = 0; &#125; @Override public void next() &#123; if (cursor&lt;list.size())&#123; cursor++; &#125; &#125; @Override public boolean hasNext() &#123; if (cursor&lt;list.size())&#123; return true; &#125; return false; &#125; @Override public boolean isFirst() &#123; return cursor==0?true:false; &#125; @Override public boolean isLast() &#123; return cursor==list.size()-1?true:false; &#125; @Override public Object getCurrentObj() &#123; return list.get(cursor); &#125; &#125;&#125; 调用1234567891011121314151617/** * 迭代器模式 */public class Client &#123; public static void main(String[] args) &#123; ConcrtetMyAggregate cma = new ConcrtetMyAggregate(); cma.addObject("aa"); cma.addObject("bb"); cma.addObject("cc"); MyIterator iterator = cma.createIterator(); while (iterator.hasNext())&#123; System.out.println(iterator.getCurrentObj()); iterator.next(); &#125; &#125;&#125; 基本案例 实现正向遍历的迭代器 实现逆向遍历的迭代器 开发中常见的场景 JDK内置的迭代器（List/Set） 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--责任链模式]]></title>
    <url>%2F2018%2F09%2F04%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义 将能够处理同一类请求的对象连成一条链，所提交的请求沿着链传递，链上的对象逐个判断是否有能力处理该请求，如果能则处理，如果不能则传递给链上的下一个对象。 场景 打牌时，轮流出牌 接力赛跑 大学中，奖学金审批 公司中，请假条审批 如果请假天数小于3天，主任审批 如果请假天数大于等于3天，小于10天，经理审批 如果大于等于10天，小于30天，总经理审批 如果大于等于30天，提示拒绝 代码解析（请假条审批）分装请假的基本信息1234567891011121314151617181920212223242526272829303132333435363738/** * 分装请假的基本信息 */public class LeaveRequest &#123; private String empName; private int leaveDays; private String reason; public String getEmpName() &#123; return empName; &#125; public void setEmpName(String empName) &#123; this.empName = empName; &#125; public int getLeaveDays() &#123; return leaveDays; &#125; public void setLeaveDays(int leaveDays) &#123; this.leaveDays = leaveDays; &#125; public String getReason() &#123; return reason; &#125; public void setReason(String reason) &#123; this.reason = reason; &#125; public LeaveRequest(String empName, int leaveDays, String reason) &#123; this.empName = empName; this.leaveDays = leaveDays; this.reason = reason; &#125;&#125; 抽象类12345678910111213141516171819202122/** * 抽象类 */public abstract class Leader &#123; protected String name; protected Leader nextLeader; //责任链上的后继模式 public Leader(String name) &#123; super(); this.name = name; &#125; //设定责任链上的后继对象 public void setNextLeader(Leader nextLeader) &#123; this.nextLeader = nextLeader; &#125; /** * 处理请求的核心方法 * @param request */ public abstract void handleRequest(LeaveRequest request);&#125; 领导具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 主任 */public class Director extends Leader &#123; public Director(String name) &#123; super(name); &#125; @Override public void handleRequest(LeaveRequest request) &#123; if(request.getLeaveDays()&lt;3)&#123; System.out.println("员工："+request.getEmpName()+"请假，天数："+request.getLeaveDays()+"，理由："+request.getReason()); System.out.println("主任："+this.name+",审批通过！"); &#125;else&#123; if(this.nextLeader != null)&#123; this.nextLeader.handleRequest(request); &#125; &#125; &#125;&#125;/** * 经理 */public class Manager extends Leader&#123; public Manager(String name) &#123; super(name); &#125; @Override public void handleRequest(LeaveRequest request) &#123; if(request.getLeaveDays()&lt;10)&#123; System.out.println("员工："+request.getEmpName()+"请假，天数："+request.getLeaveDays()+"，理由："+request.getReason()); System.out.println("经理："+this.name+",审批通过！"); &#125;else&#123; if(this.nextLeader != null)&#123; this.nextLeader.handleRequest(request); &#125; &#125; &#125;&#125;/** * 总经理 */public class GeneralManager extends Leader&#123; public GeneralManager(String name) &#123; super(name); &#125; @Override public void handleRequest(LeaveRequest request) &#123; if(request.getLeaveDays()&lt;30)&#123; System.out.println("员工："+request.getEmpName()+"请假，天数："+request.getLeaveDays()+"，理由："+request.getReason()); System.out.println("总经理："+this.name+",审批通过！"); &#125;else&#123; System.out.println("莫非"+request.getEmpName()+"不想干了？？？"); &#125; &#125;&#125; 调用123456789101112131415161718/** * 责任链模式 */public class Client &#123; public static void main(String[] args) &#123; Leader a = new Director("张三"); Leader b = new Manager("李四"); Leader c = new GeneralManager("王五"); //组织责任链关系 a.setNextLeader(b); b.setNextLeader(c); //开始请假操作 LeaveRequest request = new LeaveRequest("tom",10,"回家探亲"); a.handleRequest(request); &#125;&#125; 结果： 员工：tom请假，天数：10，理由：回家探亲 总经理：王五,审批通过！ 开发中常见的场景 Java中，异常机制就是一种责任链模式。一个try可以对应多个catch,当第一个catch不匹配类型，则自动跳到第二个catch javascript语言中，事件的冒泡和捕获机制。Java语言中，事件的处理采用观察者模式 Servlet开发中，过滤器的链式处理 Struts2中，拦截器的调用也时责任链模式 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--享元模式]]></title>
    <url>%2F2018%2F09%2F03%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[场景： 内存属性稀缺资源，不要随便浪费。如果有很多个完全相同或相似的对象，我们可以通过享元模式，节省内存。 核心 享元模式以共享的方式高效的支持大量细粒度对象的重用。 享元对象能做到共享的关键是区分了内部状态和外部状态。 内部状态：可以共享，不会随环境变化而改变 外部状态：不可以共享，会随环境变化而改变 享元模式实现： FlyweightFactory享元工厂类 创建并管理享元对象，享元池一般设计成键值对 FlyWeight抽象享元类 通常是一个接口或抽象类，声明公共方法，这些方法可以向外界提供对象的内部状态，设置外部状态。 ConcreteFlyWeight具体享元类 为内部状态提供成员变量进行存储 UnsharedConcreteFlyWright非共享享元类 不能被共享的子类可以设计为非共享享元类 模型图 代码解析（围棋案例）围棋棋子共有两种颜色，黑色和白色。他们的大小形状也都一样，唯一不一样的是他们所在棋盘的位置。那么，我们可以将它的颜色作为内部状态，将位置作为外部状态，模拟生成。 抽象享元类和具体享元类123456789101112131415161718192021222324252627282930313233343536/** * FlyWeight抽象享元类 */public interface ChessFlyWeight &#123; void setColor(String c); String getColor(); void display(Coordinate c);&#125;/** * ConcreteFlyWeight具体享元类 */class ConcreteChess implements ChessFlyWeight&#123; private String color; public ConcreteChess(String color) &#123; this.color = color; &#125; @Override public void setColor(String c) &#123; this.color = c; &#125; @Override public String getColor() &#123; return color; &#125; @Override public void display(Coordinate c) &#123; System.out.println("棋子颜色："+color); System.out.println("棋子位置:"+c.getX()+"==="+c.getY()); &#125;&#125; FlyweightFactory享元工厂类1234567891011121314151617/** * 享元工厂类 */public class ChessFlyWeightFactory &#123; //享元池对象 private static Map&lt;String,ChessFlyWeight&gt; map = new HashMap&lt;&gt;(); public static ChessFlyWeight getChess(String color)&#123; if(map.get(color)!= null)&#123; return map.get(color); &#125;else&#123; ChessFlyWeight cfw = new ConcreteChess(color); map.put(color,cfw); return cfw; &#125; &#125;&#125; UnsharedConcreteFlyWright非共享享元类123456789101112131415161718192021222324252627/** * 外部状态 */public class Coordinate &#123; private int x,y; public Coordinate(int x, int y) &#123; this.x = x; this.y = y; &#125; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getY() &#123; return y; &#125; public void setY(int y) &#123; this.y = y; &#125;&#125; 调用12345678910111213public class Client &#123; public static void main(String[] args) &#123; ChessFlyWeight chessFlyWeight1 = ChessFlyWeightFactory.getChess("黑色"); ChessFlyWeight chessFlyWeight2 = ChessFlyWeightFactory.getChess("黑色"); System.out.println(chessFlyWeight1); System.out.println(chessFlyWeight2); System.out.println("增加外部状态的处理============"); chessFlyWeight1.display(new Coordinate(10,10)); chessFlyWeight2.display(new Coordinate(20,20)); &#125;&#125; 结果： com.kid.flyweight.ConcreteChess@4554617c com.kid.flyweight.ConcreteChess@4554617c 增加外部状态的处理============ 棋子颜色：黑色 棋子位置:10============10 棋子颜色：黑色 棋子位置:20============20 享元模式开发中应用的场景： 享元模式由于其共享的特性，可以在任何池中操作，比如：线程池、数据库连接池。 String类的设计也是享元模式 优点 极大减少内存中对象的数量 相同或相似的对象内存中只存在一份，极大的节约资源，提高系统性能 外部状态相对独立，不影响内部状态 缺点 模式较复杂，是程序逻辑复杂化 为了节省内存，共享了内部状态，分离出外部状态，而读取外部状态使运行时间边长。用时间换取了空间。 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--外观模式]]></title>
    <url>%2F2018%2F09%2F01%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[迪米特法则（最少知识原则） 一个软件实体应当尽可能少的与其他实体发生相互作用 外观模式的核心 为子系统提供统一的入口，封装子系统的复杂性，便于客户端被调用。 基本案例（泡茶流程代码解析）准备必要工具（茶具、茶叶、水、喝茶的人）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/** * 茶具接口 */public interface TeaSet &#123; void useTeaSet();&#125;class CoveredTeaSet implements TeaSet&#123; @Override public void useTeaSet() &#123; System.out.println("使用盖碗茶具"); &#125;&#125;class FlowerReceptacle implements TeaSet&#123; @Override public void useTeaSet() &#123; System.out.println("使用玻璃杯"); &#125;&#125;class DarkRedEnameledPottery implements TeaSet&#123; @Override public void useTeaSet() &#123; System.out.println("使用紫砂壶"); &#125;&#125;/** * 茶叶 */public interface Tea &#123; void useTea();&#125;class BiluochunTea implements Tea&#123; @Override public void useTea() &#123; System.out.println("使用碧螺春"); &#125;&#125;class JasmineTea implements Tea&#123; @Override public void useTea() &#123; System.out.println("使用茉莉花茶"); &#125;&#125;class PuerTea implements Tea&#123; @Override public void useTea() &#123; System.out.println("使用普洱"); &#125;&#125;/** * 水 */public interface Water &#123; void useWater();&#125;class BoilingWater80 implements Water&#123; @Override public void useWater() &#123; System.out.println("使用80度开水"); &#125;&#125;class BoilingWater90 implements Water&#123; @Override public void useWater() &#123; System.out.println("使用90度开水"); &#125;&#125;class BoilingWater100 implements Water&#123; @Override public void useWater() &#123; System.out.println("使用100度开水"); &#125;&#125;/** * 人 */public class People &#123; String name; public People(String name) &#123; this.name = name; &#125; public People() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 使用非外观者模式自己泡茶12345678910111213141516171819/** * 外观模式 调用者 */public class Client &#123; public static void main(String[] args) &#123; /** * 使用非外观者模式 泡茶 */ People huangYaoShi = new People("黄药师"); TeaSet darkRedEnameledPottery = new DarkRedEnameledPottery(); darkRedEnameledPottery.useTeaSet(); Tea puerTea = new PuerTea(); puerTea.useTea(); Water boilingWater100 = new BoilingWater100(); boilingWater100.useWater(); System.out.println(huangYaoShi.getName()+"自己泡茶"); &#125;&#125; 结果： 使用紫砂壶 使用普洱 使用100度开水 黄药师自己泡茶 由上可以看出自己泡茶需要调用的东西极多，颇为复杂。 使用外观者模式茶馆喝茶1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 泡茶流程的门面对象（茶馆） */public class MakeTea &#123; public void make(String teaName,String username)&#123; TeaSet teaSet = null; Tea tea = null; Water water = null; switch (teaName)&#123; case "puer": teaSet = new DarkRedEnameledPottery(); teaSet.useTeaSet(); tea = new PuerTea(); tea.useTea(); water = new BoilingWater100(); water.useWater(); System.out.println("为"+username+"泡茶"); break; case "biluochun": teaSet = new CoveredTeaSet(); teaSet.useTeaSet(); tea = new BiluochunTea(); tea.useTea(); water = new BoilingWater80(); water.useWater(); System.out.println("为"+username+"泡茶"); break; case "jasmine": teaSet = new FlowerReceptacle(); teaSet.useTeaSet(); tea = new JasmineTea(); tea.useTea(); water = new BoilingWater90(); water.useWater(); System.out.println("为"+username+"泡茶"); break; default: this.make("jasmine",username); break; &#125; &#125;&#125;/** * 外观模式 调用者 */public class Client &#123; public static void main(String[] args) &#123; /** * 使用外观者模式泡茶 */ MakeTea makeTea = new MakeTea(); People ouyangfeng = new People("欧阳锋"); makeTea.make("biluochun",ouyangfeng.getName()); &#125;&#125; 结果： 使用盖碗茶具 使用碧螺春 使用80度开水 为欧阳锋泡茶 所以，自己泡茶还是茶馆喝茶，你，选择好了吗？ 开发中常用的场景 频率很高。哪里都会遇到。各种技术和框架中，都有外观模式的使用。如： JDBC封装后，commons提供的DBUtils类，Hibernate提供的工具类、Spring JDBC工具类等。 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--装饰模式]]></title>
    <url>%2F2018%2F09%2F01%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[职责 动态的为一个对象增加新的功能 装饰模式是一种用于代替继承的技术，无须通过继承增加子类就能扩展对象的新功能。使对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。 实现细节 Component抽象构建角色 真实对象和装饰对象有相同的接口，这样，客户端对象就能够以真实对象相同的方式装饰对象交互。io流中的InputStream、OutputStream、Reader、Writer ContreteComponent具体构建角色（真实对象）： io流中的FileInputStream、FileOutputStream Decorator装饰角色： 持有一个抽象构建的引用。装饰对象接受所有客户端的请求，并把这些请求转发给真实的对象，这样，就能在真实对象的调用前后增加新的功能。io流中的FilterInputStream、FilterOutputStream CpncreteDecorator具体装饰角色： 负责给构件对象增加新的责任。io流中的BufferedOutputStream、BufferedInputStream等 模拟汽车多种模式抽象组件Component123456/** * 抽象组件 */public interface ICar &#123; void move();&#125; 具体构件对象ContreteComponent123456789/** * 具体构件对象 */class Car implements ICar&#123; @Override public void move() &#123; System.out.println("陆地上跑"); &#125;&#125; 装饰器角色 Decorator12345678910class SuperCar implements ICar&#123; protected ICar car; public SuperCar(ICar car) &#123; this.car = car; &#125; @Override public void move() &#123; car.move(); &#125;&#125; 具体装饰对象CpncreteDecorator1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 具体装饰对象 天上飞类型 */class FlyCar extends SuperCar &#123; public FlyCar(ICar car) &#123; super(car); &#125; @Override public void move() &#123; super.move(); fly(); &#125; public void fly()&#123; System.out.println("天上飞"); &#125;&#125;/** * 具体装饰对象 水上游类型 */class WaterCar extends SuperCar &#123; public WaterCar(ICar car) &#123; super(car); &#125; @Override public void move() &#123; super.move(); swim(); &#125; public void swim()&#123; System.out.println("水上游"); &#125;&#125;/** * 具体装饰对象 自动跑类型 */class AICar extends SuperCar &#123; public AICar(ICar car) &#123; super(car); &#125; @Override public void move() &#123; super.move(); autoMove(); &#125; public void autoMove()&#123; System.out.println("自动跑"); &#125;&#125; 调用12345678910111213141516171819202122/** *装饰器模式 */public class Client &#123; public static void main(String[] args) &#123; System.out.println("=============汽车功能============"); Car car = new Car(); car.move(); System.out.println("=============增加功能，飞行============"); FlyCar flyCar = new FlyCar(car); flyCar.move(); System.out.println("=============增加功能，水里游============"); WaterCar waterCar = new WaterCar(car); waterCar.move(); System.out.println("=============增加功能，飞行，水里游============"); WaterCar waterCar1 = new WaterCar(new FlyCar(car)); waterCar1.move(); &#125;&#125; 结果结果： =============汽车功能============ 陆地上跑 =============增加功能，飞行============ 陆地上跑 天上飞 =============增加功能，水里游============ 陆地上跑 水上游 =============增加功能，飞行，水里游============ 陆地上跑 天上飞 水上游 开发中使用的场景： IO中输入流和输出流的设计 Swing包中图形界面构件功能 Servlet API中提供了一个request对象的Decorator设计模式的默认实现类HttpServerRequestWrapper,HttpServletRequestWrapper类，增强了request对象的功能 Struts2中，request，response,session对象的处理 总结 装饰模式（Decorator）也叫包装器模式（Wrapper） 装饰模式降低系统的耦合度，可以动态的增加或删除对象的职责，并使得需要装饰的具体构建类和具体装饰类可以独立变化，以便增加新的具体构建类和具体装饰类 优点 扩展对象功能，比继承灵活，不会导致类个数急剧增加 可以对一个对象进行多次装饰，创造出不同行为的组合，得到功能更强大的对象 具体构建类和具体装饰类可以独立变化，用户可以根据需要自己增加新的具体构件子类和具体装饰子类 缺点 产生很多小对象。大量的小对象占据内存，一定程度上影响性能。 装饰模式易于出错，调试排查比较麻烦 装饰模式和桥接模式的区别 两个模式都是为了解决过多的子类对象问题。但是他们的诱因不一样。桥接模式是对象自身现有机制沿着多个维度变化，是既有部分不稳定。装饰模式是为了增加新的功能 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--组合模式]]></title>
    <url>%2F2018%2F08%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[使用组合模式的场景 把部分和整体的关系用树形结构来表示，从而使客户端可以使用统一的方式处理部分对象和整体对象。 组合模式的核心 抽象构建（Component）角色：定义了叶子和容器构件的共同点 叶子（Leaf）构件角色：无子节点 容器（Composite）构件角色：有容器特征，可以包含子节点 12345678910111213141516171819202122/** * 抽象组件 */public interface Component &#123; void operation();&#125;/** * 叶子组件 */interface Leaf extends Component&#123;&#125;/** * 容器组件 */interface Composite extends Component&#123; void add(Component c); void remove(Component c); Component getChild(int index);&#125; 组合模式工作流程分析 组合模式为处理树形结构提供了完美的解决方案，描述了如何将容器和叶子进行递归组合，使得用户在使用时可以一致性的对待容器和叶子。 当容器对象的指定方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员，并调用执行。其中，使用了递归的机制对整个结构进行处理。 使用组合模式，模拟杀毒软件架构设计下面，我们使用组合模式，来模拟杀毒过程。我们先定义抽象组件，定义其共同点。其次，我们定义叶子节点（图片文件、文本文件、视频文件）。之后，我们定义容器组件（文件夹）。容器组件中，我们使用递归方法进行查杀，直到叶子节点查杀完毕。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * 抽象组件 */public interface AbstractFile &#123; void killVirus();&#125;/** * 叶子组件 图片文件 */class ImageFile implements AbstractFile&#123; private String name; public ImageFile(String name) &#123; super(); this.name = name; &#125; @Override public void killVirus() &#123; System.out.println("--图片文件："+name+"进行查杀"); &#125;&#125;/** * 叶子组件 文本文件 */class TextFile implements AbstractFile&#123; private String name; public TextFile(String name) &#123; super(); this.name = name; &#125; @Override public void killVirus() &#123; System.out.println("--文本文件："+name+"进行查杀"); &#125;&#125;/** * 叶子组件 视频文件 */class VideoFile implements AbstractFile&#123; private String name; public VideoFile(String name) &#123; super(); this.name = name; &#125; @Override public void killVirus() &#123; System.out.println("--视频文件："+name+"进行查杀"); &#125;&#125;/** * 容器组件 */class Folder implements AbstractFile&#123; private String name; //定义容器，用来存放本容器构建下的子节点 private List&lt;AbstractFile&gt; list = new ArrayList&lt;&gt;(); public Folder(String name) &#123; this.name = name; &#125; public void add(AbstractFile abstractFile)&#123; list.add(abstractFile); &#125; public void romove(AbstractFile abstractFile)&#123; list.remove(abstractFile); &#125; public AbstractFile getChile(int index)&#123; return list.get(index); &#125; @Override public void killVirus() &#123; System.out.println("==文件夹："+name+"进行查杀"); for (AbstractFile file: list) &#123; file.killVirus(); &#125; &#125;&#125; 调用执行：模拟文件夹存放模式，在文件夹我的收藏里存放一个图像，一个文本，一个电影文件夹，在电影文件夹中，我们存放两个视频文件。模拟查杀模式。我们只需调用我的收藏进行查杀，其下包括其都将进行查杀。 1234567891011121314151617181920public class Client &#123; public static void main(String[] args) &#123; AbstractFile f2,f3,f4,f5,f6; Folder f1 = new Folder("我的收藏"); f2 = new ImageFile("头像.jpg"); f3 = new TextFile("Hello.txt"); f1.add(f2); f1.add(f3); // f1.killVirus(); Folder f11 = new Folder("电影"); f4 = new VideoFile("笑傲江湖.avi"); f5 = new VideoFile("神雕侠侣.avi"); f11.add(f4); f11.add(f5); f1.add(f11); f1.killVirus(); &#125;&#125; 结果： ==文件夹：我的收藏进行查杀 --图片文件：头像.jpg进行查杀 --文本文件：Hello.txt进行查杀 ==文件夹：电影进行查杀 --视频文件：笑傲江湖.avi进行查杀 --视频文件：神雕侠侣.avi进行查杀 开发中的应用场景： 操作系统的资源管理器 GUI中的容器层次图 XML文件解析 OA系统中，组织结构的处理 Junit单元测试框架 底层设计就是典型的组合模式，TestCase（叶子）、TestUnit(容器)、Test接口（抽象） 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--桥接模式]]></title>
    <url>%2F2018%2F08%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[场景 商城系统中常见的商品分类，以电脑为类，如何良好的处理商品分类销售的问题？如图所示，我们的电脑有很多的品牌，如联想，戴尔等。同时，我们的电脑有很多的品类，如台式机，笔记本，平板电脑等。那么，我们组合展示电脑的时候，我们一般会使用多层继承结构实现图中关系： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.kid.bridge;public interface Computer &#123; void sale();&#125;class Desktop implements Computer&#123; @Override public void sale() &#123; System.out.println("销售台式机"); &#125;&#125;class Laptop implements Computer&#123; @Override public void sale() &#123; System.out.println("销售笔记本"); &#125;&#125;class LenovoDesktop extends Desktop&#123; @Override public void sale() &#123; System.out.println("销售联想台式机"); &#125;&#125;class LenovoLaptop extends Laptop&#123; @Override public void sale() &#123; System.out.println("销售联想笔记本"); &#125;&#125;class DellDesktop extends Desktop&#123; @Override public void sale() &#123; System.out.println("销售戴尔台式机"); &#125;&#125;class DellLaptop extends Laptop&#123; @Override public void sale() &#123; System.out.println("销售戴尔笔记本"); &#125;&#125; 一件商品的展示，我们需要耗费很大的时间。就有如下问题发生： 扩展性问题： 如果要增加一个新的电脑类型，平板电脑，则要怎加各个品牌下面的类。 如果要增加一个新的品牌，也要增加各种电脑类型的类。 违反单一职责原则： 一个类：联想笔记本，有两个引起这个类变化的原因 场景分析 这个场景中有两个变化的维度：电脑类型、电脑品牌。那么，我们可以建立两个不同的维度，通过某些连接，使其两两不同组合。– &gt; 桥接模式 桥接模式的核心要点 处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。 代码解析我们先建造电脑品牌维度1234567891011121314151617181920212223/** * 电脑品牌维度 */public interface Brand &#123; void sale();&#125;class Lenovo implements Brand&#123; @Override public void sale() &#123; System.out.println("销售联想电脑"); &#125;&#125;class Dell implements Brand&#123; @Override public void sale() &#123; System.out.println("销售戴尔电脑"); &#125;&#125; 再建造电脑类型维度1234567891011121314151617181920212223242526272829303132333435363738394041/** * 电脑类型维度 */public class Computer2 &#123; protected Brand brand; public Computer2(Brand brand) &#123; this.brand = brand; &#125; public void sale()&#123; brand.sale(); &#125;&#125;class Desktop2 extends Computer2&#123; public Desktop2(Brand brand) &#123; super(brand); &#125; @Override public void sale() &#123; super.sale(); System.out.println("销售台式机"); &#125;&#125;class Laptop2 extends Computer2&#123; public Laptop2(Brand brand) &#123; super(brand); &#125; @Override public void sale() &#123; super.sale(); System.out.println("销售笔记本"); &#125;&#125; 调用：12345678910/** * 桥接模式 */public class Client &#123; public static void main(String[] args) &#123; //销售联想笔记本电脑 Computer2 c = new Laptop2(new Lenovo()); c.sale(); &#125;&#125; 这样，我们就很轻松的实现业务需求。即使增加新的品类或者品牌。也只需要增加部分代码就可以，而无需改动太多。 桥接模式实际开发中应用场景 JDBC驱动程序 AWT中的Peer架构 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--代理模式]]></title>
    <url>%2F2018%2F08%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代理模式（proxy pattern） 核心作用 通过代理，控制对对象的访问可以详细控制访问某个（某类）对象的方法，在调用这个方法浅做前置处理，调用这个方法后做后置处理。（即：AOP的微观实现） AOP（Aspect Oriented Programming 面向切面编程）的核心实现机制 核心角色 抽象角色 定义代理角色和真实角色的公共对外方法 真实角色 实现抽象角色，定义真实角色所需要实现的业务逻辑，供代理角色调用 关注真正的业务逻辑 代理角色 实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。 将统一的流程控制放到代理角色中处理！ 安全场景 安全代理：屏蔽对真实角色的直接访问 远程代理：通过代理类处理远程方法调用（RMI） 延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象。 分类 静态代理（静态定义代理类） 动态代理（动态生成代理类） jdk自带的动态代理 javaassist字节码操作库是实现 CGLIB ASM（底层使用指令，可维护性较差） 代码解析我们用现实生活中的明星和经纪人举个例子：建一个明星接口，代表明星日常所需要做的事情。1234567891011121314151617181920212223242526public interface Star &#123; /** * 面谈 */ void confer(); /** * 签合同 */ void signContract(); /** * 订票 */ void bookTickect(); /** * 唱歌 */ void sing(); /** * 收钱 */ void collectMoney();&#125; 然后我们实现一下接口，构建一个“真实”的明星1234567891011121314151617181920212223242526272829/** *真实角色 */public class RealStar implements Star&#123; @Override public void confer() &#123; System.out.println("RealStar.confer()"); &#125; @Override public void signContract() &#123; System.out.println("RealStar.signContract()"); &#125; @Override public void bookTickect() &#123; System.out.println("RealStar.bookTickect()"); &#125; @Override public void sing() &#123; System.out.println("RealStar（周杰伦本人）.sing()"); &#125; @Override public void collectMoney() &#123; System.out.println("RealStar.collectMoney()"); &#125;&#125; 静态代理在静态代理中，我们需要一个专门的代理类，去实现明星接口，代替明星完成一些事情，那么我们看一下明星日常需要完成的类，只有唱歌，是需要本人完成，其他的事情都可以由经纪人代理。那么，我们就只需要在sing()方法里调用真实唱歌类就可以了。123456789101112131415161718192021222324252627282930313233343536/** * 代理人 */public class ProxyStar implements Star&#123; private Star star; @Override public void confer() &#123; System.out.println("ProxyStar.confer()"); &#125; @Override public void signContract() &#123; System.out.println("ProxyStar.signContract()"); &#125; @Override public void bookTickect() &#123; System.out.println("ProxyStar.bookTickect()"); &#125; @Override public void sing() &#123; star.sing(); &#125; @Override public void collectMoney() &#123; System.out.println("ProxyStar.collectMoney()"); &#125; public ProxyStar(Star star) &#123; super(); this.star = star; &#125;&#125; 我们调用一下代理方法，来看下效果：12345678910111213141516/** * 静态代理（我们自己定义代理） */public class Client &#123; public static void main(String[] args) &#123; Star real = new RealStar(); Star proxy = new ProxyStar(real); proxy.confer(); proxy.signContract(); proxy.bookTickect(); proxy.sing(); proxy.collectMoney(); &#125;&#125; 结果： ProxyStar.confer() ProxyStar.signContract() ProxyStar.bookTickect() RealStar（周杰伦本人）.sing() ProxyStar.collectMoney() 动态代理我们在来看下动态代理,和静态代理不同，我们只需要实现InvocationHandler接口，重写invoke()方法就可实现代理。12345678910111213141516171819202122232425262728import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;/** * 核心 */public class StarHandler implements InvocationHandler &#123; Star realStar; public StarHandler(Star realStar) &#123; super(); this.realStar = realStar; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object object = null; System.out.println("真正的方法执行前！"); //调用方法 此处简化 System.out.println("面谈，签合同，订票"); if(method.getName().equals("sing"))&#123; object = method.invoke(realStar,args); &#125; System.out.println("真正的方法执行后！"); System.out.println("收尾款"); return object; &#125;&#125; 同样，我们调用一下方法，看下结果：12345678910111213import java.lang.reflect.Proxy;/** * 动态代理 */public class Client &#123; public static void main(String[] args) &#123; Star realStar = new RealStar(); StarHandler handler = new StarHandler(realStar); Star proxy = (Star) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]&#123;Star.class&#125;,handler); proxy.sing(); &#125;&#125; 结果： 真正的方法执行前！ 面谈，签合同，订票 RealStar（周杰伦本人）.sing() 真正的方法执行后！ 收尾款 同样的，我们实现了代理。 动态代理相比于静态代理的优点 抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法处理，这样，我们可以更加灵活和统一的处理众多的方法。 JDK自带的动态代理 java.lang.reflect.Proxy 作用：动态生成代理类和对象 java.lang.reflect.InvocationHandler(处理器接口) 可以通过invoke方法实现对真实角色的代理访问 每次通过Proxy身材代理类对象时都要指定对应的处理器对象 开发框架中应用场景 struts2中拦截器的实现 数据库连接池关闭处理 Hibernate中延时加载的实现 mybatis中实现拦截器插件 AspectJ的实现 spring中AOP的实现 日志拦截 声明式事务处理 web service RMI远程方法调用 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--适配器模式]]></title>
    <url>%2F2018%2F08%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是适配器模式 将一个类的接口转换成客户希望的另外一个接口。adapter就是将原本由于接口不兼容而不能一起工作的类可以在一起工作。 模式中的角色 目标接口（target）:客户所期待的接口，目标可以是具体的或者抽象的类，也可以是接口 需要适配的类（adaptee）：需要适配的类或适配者类 适配器（adapter）:通过报纸一个需要的适配的对象，把原接口转换成目标接口。 实例解析我们日常生活中用到适配器的情况其实很多，比如说，我们有一个可以适配台式机的键盘（PS/2），当我们想同样用在笔记本电脑上（USB），那我们就需要一个转接器，这个时候，我们的目标接口就是笔记本电脑(USB接口)，而我们需要适配的类就是键盘（PS/2）,适配器就是我们的转接器。下面，我们来用代码解析一下。 代码解析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 目标接口 * USB */public interface Target &#123; void handleRequest();&#125;/** * 需要适配的类 * （相当于例子中的，PS/2键盘） */public class Adaptee &#123; public void request()&#123; System.out.println("可以实现客户需求功能 "); &#125;&#125;/** * 适配器 * （相当于user和ps/2转接器） */public class Adapter implements Target&#123; private Adaptee adaptee; @Override public void handleRequest() &#123; adaptee.request(); &#125; public Adapter(Adaptee adaptee) &#123; super(); this.adaptee = adaptee; &#125;&#125;/** * 客户端类 * （相当于例子中的笔记本，只有USB接口） */public class Client &#123; public void test1 (Target t)&#123; t.handleRequest(); &#125; public static void main(String[] args) &#123; Client c = new Client(); Adaptee a = new Adaptee(); Target t = new Adapter(a); t.handleRequest(); &#125;&#125; 工作中的场景 经常用来做旧系统改造和升级 如果我们的系统开发后再也不需要维护，那么很多模式都是没必要的，但不幸的是，事实确实维护一个系统的代价往往是开发一个系统的数倍 我们学习中见过的场景 java.io.InputStreamReader(InputStream) java.io.OutputStreamWriter(OutputStream) 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一路走来]]></title>
    <url>%2F2018%2F08%2F17%2F%E9%9A%8F%E4%BE%BF%E5%8F%A8%E5%8F%A8%2F%E4%B8%80%E8%B7%AF%E8%B5%B0%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[初入坑2013年夏，糊里糊涂的就选了计算机专业，这对于高中计算机课作业都头疼的人来说，绝不是一个好的消息。颓废度日或许是日后的选择。“无奈”初入校门的第一堂C语言课，就遇到系里“有名”的严格老师。“被迫”之下，愉快的开始了编程史~~ 负增长过了初始敲出一段代码，兴奋到不行的阶段，兴趣开始负增长。仅剩下的一点学习的动力，大概也是为了获取给同学解决bug，被称赞时的荣耀感。 初入行怀揣着学校里获取的荣耀感，打算“大杀四方”，却无奈妥协，却依然未认清自己。没有了学校里的被动学习状态，简直是放飞自我。而且一再的自我感觉良好。直到，之前以为“志同道合”的小伙伴获取了一份不错的offer。决定开始自主学习。 拖延症+焦虑症了解的越多，才知道自己懂的太少。焦虑症病发，伴随着拖延症接踵而来。想学习，需要学的东西太多，先学什么？如同瞎子摸鱼。之后就不了了之。 觉悟季+打卡季另一个志同道合的小伙伴也走了，去寻找更好的未来。开始有些觉悟，决心踏踏实实沉下心来，一步一步走。利用空闲时间，学东西，撸代码，写博客。 代码之悟越来越开始注重代码的质量，写一段好的代码，就如同写一份优雅文章。 博客之悟 从刚开始的不会就百度，之后就忘记。 到后来的百度后记录，却知其然不知其所以然。 再之后，知其然，也之其所以然，却仅仅只是知道，却无法完美的表述。看似自己写的博客，面面俱到，却只是徒有其表。 之后目标，一篇好的文章，需要字字斟酌，浅显易懂。不仅要让自己看懂，也要让别人看懂。 未来之路希望志同道合的小伙伴们会一直志同道合，而不是在某个瞬间，被甩远，到最后，只剩下仰望。 To Lao Wang , Lao Nan]]></content>
      <categories>
        <category>随便叨叨</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--原型模式]]></title>
    <url>%2F2018%2F08%2F17%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[what is the prototype model(原型模式是什么)？ 用原型实例制定创建的对象的种类，并且通过拷贝这些原型创建新的对象 就是通过JAVA的克隆技术，以某个对象为原型，复制出新的对象。显然，新的对象具备原型对象的特点 克隆类似于new，但是不同于new。new创建的对象属性采用的是默认值。克隆出的对象属性值于原型对象相同。并且克隆出的新对象改变不会影响原型对象。然后，再修改克隆对象的值。 Why use prototype mode（为什么要用原型模式）? 通过new产生的一个对象需要非常繁琐的数据准备或访问权限，则可以用原型模式。 优势有：效率高（直接克隆，避免了重新构造过程的步骤） 浅复制和深复制浅复制和深复制是个什么鬼？憋说话，我们先上代码。 浅复制代码解析我们先来建一个羊的实体类，属性包括名称和出生日期。如果想实现克隆（复制），我们需要实现Cloneable接口。重写他的clone方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Sheep implements Cloneable&#123; private String sname; private Date birthday; public String getSname() &#123; return sname; &#125; public void setSname(String sname) &#123; this.sname = sname; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; Object obj = super.clone(); return obj; &#125; public Sheep(String sname, Date birthday) &#123; this.sname = sname; this.birthday = birthday; &#125; public Sheep() &#123; &#125;&#125;```` 我们来测试一下，实例化两个羊，我们来看看不同。（如果没有原型模式，那我们多半会直接new 两个Sheep，这样确实可以实现需求，可是，就考虑代码性能方面来看，每次调用构造方法，都会造成大量的资源耗损，那么，我们来试试传说中的原型模式）使用clone()方法，我们来构建s2(第二只羊)。然后将他们的属性都打印出来。````java/** * 测试原型模式(浅克隆) * 克隆分（深克隆和浅克隆） */public class Client &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Date date = new Date(234234234234L); Sheep s1 = new Sheep("小羊",date); Sheep s2 = (Sheep) s1.clone(); System.out.println(s1); System.out.println(s1.getSname()); System.out.println(s1.getBirthday()); date.setTime(123123132L); System.out.println(s1.getBirthday()); s2.setSname("大羊"); System.out.println(s2); System.out.println(s2.getSname()); System.out.println(s2.getBirthday()); &#125;&#125; 结果： com.kid.prototype.Sheep@4554617c 小羊 Sat Jun 04 09:03:54 CST 1977 Fri Jan 02 18:12:03 CST 1970 com.kid.prototype.Sheep@7f31245a 大羊 Fri Jan 02 18:12:03 CST 1970 分析结果，可以发现 s1和s2是两个不同的实体类。而且我们在克隆s2之后，改变其sname参数的值，也没有影响到原模型的参数。但是！我们发现我们在改变s1的date参数的时候，直接影响到了s2的结果。那么就涉及到之前所提的深复制浅复制了。 深复制浅复制解析 浅复制：当原型对象被复制时，只复制它本身和其中包含的值类型的成员变量，而引用类型的成员变量并没有复制。 深复制：在计算机中开辟了一块新的内存地址用于存放复制的对象。 深复制和浅复制最根本的区别在于是否是真正获取了一个对象的复制实体，而不是引用。 深复制代码解析我们将实体类中的clone方法重写12345678@Overrideprotected Object clone() throws CloneNotSupportedException &#123; Object obj = super.clone(); //添加如下代码实现深复制 Sheep2 s = (Sheep2) obj; s.birthday = (Date) this.birthday.clone(); //把属性也形象克隆 return obj;&#125; 然后再调用测试方法测试一下 结果： com.kid.prototype.Sheep2@4554617c 小羊 Sat Jun 04 09:03:54 CST 1977 Fri Jan 02 18:12:03 CST 1970 com.kid.prototype.Sheep2@7f31245a 大羊 Sat Jun 04 09:03:54 CST 1977 我们会发现，这个时候，s2的出生日期和s1未修改之前的日期一样，这样我们就实现了深复制。 原型模式图结构图 原型模式实现 Cloneable接口和clone方法 prototype模式中实现起来最困难的地方就是内存复制操作，所幸java中提供了clone方法替我们做了绝大部分事情。 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--建造者模式]]></title>
    <url>%2F2018%2F08%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[场景 建造一个复杂的产品 实际开发中，我们构建的对象非常复杂时 建造模式的本质 分离了对象子组件的单独构造（由Builder来负责）和装配（由Director负责），从而构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况下使用。 由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的购建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。 白话解析我们建造一个非常复杂的产品，比如说宇宙飞船时，为了在构建和组装飞船的时候‘不缺胳膊少腿’，我们需要将一个产品的内部表象和产品的生产过程分割（分批行动，较为稳妥），具体分为两步： 构建很多零件（Builder） 把零件组装起来（Director） 代码示例生成实体类先将宇宙飞船抽象化，假设有轨道舱，发动机和逃逸塔等部分，我们先定义实体类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/** * 宇宙飞船 实体类 */public class AirShip &#123; private OrbitalModule orbitalModule; //轨道舱 private Engine engine; //发动机 private EscapeTower escapeTower; //逃逸塔 /** * 发动机 */ public void launch()&#123; System.out.println("我是发动机"); &#125; public AirShip()&#123; &#125; public AirShip(OrbitalModule orbitalModule, Engine engine, EscapeTower escapeTower) &#123; this.orbitalModule = orbitalModule; this.engine = engine; this.escapeTower = escapeTower; &#125; public OrbitalModule getOrbitalModule() &#123; return orbitalModule; &#125; public void setOrbitalModule(OrbitalModule orbitalModule) &#123; this.orbitalModule = orbitalModule; &#125; public Engine getEngine() &#123; return engine; &#125; public void setEngine(Engine engine) &#123; this.engine = engine; &#125; public EscapeTower getEscapeTower() &#123; return escapeTower; &#125; public void setEscapeTower(EscapeTower escapeTower) &#123; this.escapeTower = escapeTower; &#125;&#125;/** * 轨道舱 */class OrbitalModule&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public OrbitalModule(String name) &#123; this.name = name; &#125;&#125;/** * 发动机 */class Engine&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Engine(String name) &#123; this.name = name; &#125;&#125;/** * 逃逸舱 */class EscapeTower&#123; private String name; public EscapeTower(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 构建零件定义完实体类（此处我理解为：画好图纸）以后，我们开始构建对应的组件，即建造发动机、轨道舱、逃逸塔。此处定义了接口和实现类，便于扩展和维护。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 构造方法 * 构建子组件 */public interface AirShipBuilder &#123; /** * 构建发动机 * @return */ Engine builderEngine(); /** * 构建轨道舱 * @return */ OrbitalModule builderOrbitalModule(); /** * 构建逃逸塔 * @return */ EscapeTower builderEscapeTower();&#125;/** * 构建者实现类 */public class AirShipBuilderImpl implements AirShipBuilder &#123; @Override public Engine builderEngine() &#123; System.out.println("我是发动机"); return new Engine("发动机"); &#125; @Override public OrbitalModule builderOrbitalModule() &#123; System.out.println("我是轨道舱"); return new OrbitalModule("轨道舱"); &#125; @Override public EscapeTower builderEscapeTower() &#123; System.out.println("我是逃逸舱"); return new EscapeTower("逃逸舱"); &#125;&#125; 装配呐，如果我们是建宇宙飞船的指挥者，那我们就可以站在零件生产完毕后，指挥将他们安装一定规则组装。这样，就不会出错了。123456789101112131415161718192021222324252627282930313233343536/** * 装配(组装) */public interface AirShipDirector &#123; /** * 组装宇宙飞船 * @return */ AirShip directAirship();&#125;/** * 装配者实现 */public class AirShipDirectorImpl implements AirShipDirector &#123; private AirShipBuilder airShipBuilder; public AirShipDirectorImpl (AirShipBuilder airShipBuilder)&#123; this.airShipBuilder = airShipBuilder; &#125; @Override public AirShip directAirship() &#123; Engine e = airShipBuilder.builderEngine(); OrbitalModule o = airShipBuilder.builderOrbitalModule(); EscapeTower et = airShipBuilder.builderEscapeTower(); AirShip airShip = new AirShip(); airShip.setEngine(e); airShip.setEscapeTower(et); airShip.setOrbitalModule(o); return airShip; &#125;&#125; 调用123456789101112/** * 调用者 * 建造者模式 */public class Client &#123; public static void main(String[] args) &#123; AirShipDirector director = new AirShipDirectorImpl(new AirShipBuilderImpl()); AirShip airShip = director.directAirship(); airShip.launch(); &#125;&#125; uml 类图 开发中应用场景： StringBuilder 类的append 方法 Sql中的PreparedStatement JDOM中，DomBulider、SAXBuilder 在实际应用中，可以和和工厂模式搭配.先用工厂模式构建零件，再用建造者模式装配 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序算法]]></title>
    <url>%2F2018%2F04%2F14%2F%E7%AE%97%E6%B3%95%2F%E6%8E%92%E5%BA%8F%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[快速排序基本思想通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 算法介绍 设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。一趟快速排序的算法是： 设置两个变量i、j，排序开始的时候：i=0，j=N-1； 以第一个数组元素作为关键数据，赋值给key，即key=A[0]； 从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换； 从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换； 重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。 流程假设我们将数组里插入一组数据：3 4 2 6 1 8 5 那我们将3赋值给key,此时：i=0;j=6;key=3; 首先，我们需要从后向前查找比key小的值，此时我们拿key的值，和j所在的位置的数字进行比较，3 &lt; 5，显然不满足，j– 重复第2条，直达j=4的时候，3 &gt; 1 。此时：i=0;j=4;key=3; 将i和j所在位置的值互换，此时组中的数据为1 4 2 6 3 8 5，i=0;j=4;key=3; 这时，我们需要从前往后找比key大的值，当i=1时，3 &lt; 4， 将i和j所在位置的值互换，此时组中的数据为1 3 2 6 4 8 5，i=1;j=4;key=3; 重复2-6步，直到i=j，此为一轮比较，此时，key左边的值都比key小，右边的值都比key大 3 4 2 6 1 8 5, i=0;j=6;key=3 1 4 2 6 3 8 5, i=0;j=4;key=3 后到前 1 3 2 6 4 8 5, i=1;j=4;key=3 前到后 1 2 3 6 4 8 5, i=1;j=2;key=3 后到前 1 2 3 6 4 8 5, i=2;j=2;key=3 前到后 将数据分为两组，第一组：1 2 3；第二组：6 4 8 5 ；将两组数据分别按照1-7步分别排序，此次只演示第二组数据： 6 4 8 5, i=0;j=3;key=6 5 4 8 6, i=0;j=3;key=6 后到前 5 4 6 8, i=2;j=3;key=6 前到后 5 4 6 8, i=2;j=2;key=6 后到前 5 4 6, i=0;j=2;key=5 4 5 6, i=0;j=1;key=5 后到前 4 5 6, i=1;j=1;key=5 前到后 排序完成,最后结果：1 2 3 4 5 6 8 java代码实例12345678910111213141516171819202122232425262728293031323334353637383940/** * 快速排序算法 */public class QuickAlgorithm &#123; public static void main(String[] args) &#123; int [] array = &#123;3,4,2,6,1,8,5&#125;; Quick.sort(array,0,6); System.out.println(Arrays.toString(array)); &#125;&#125;class Quick&#123; public static int partition(int []array,int lo,int hi)&#123; //固定的切分方式 int key=array[lo]; while(lo&lt;hi)&#123; //从后半部分向前扫描 while(array[hi]&gt;=key&amp;&amp;hi&gt;lo)&#123; hi--; &#125; array[lo]=array[hi]; //从前半部分向后扫描 while(array[lo]&lt;=key&amp;&amp;hi&gt;lo)&#123; lo++; &#125; array[hi]=array[lo]; &#125; array[hi]=key; return hi; &#125; public static void sort(int[] array,int lo ,int hi)&#123; if(lo&gt;=hi)&#123; return ; &#125; int index=partition(array,lo,hi); sort(array,lo,index-1); sort(array,index+1,hi); &#125;&#125; 本文代码选自：快速排序（java实现）]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金三银四java面试锦集（一）]]></title>
    <url>%2F2018%2F04%2F14%2FJava%E9%9D%A2%E8%AF%95%E9%A2%98%2F%E9%87%91%E4%B8%89%E9%93%B6%E5%9B%9Bjava%E9%9D%A2%E8%AF%95%E9%94%A6%E9%9B%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java基础1. List 和 Set 的区别 List和set同属于Collection的子类： 是否有序：List是有序的，set是无序的（TreeSet通过 Comparator 或者 Comparable 维护了一个排序顺序。） 是否重复：List是可重复的，set是不可重复的 是否为空：List允许有多个null，set只允许有一个为null 拓展： Map和List、set的区别（Map不属于Collection的子类）： Map是无序的 Map的键不允许重复，值允许重复 Map的键只允许有一个null，值允许多个null 2. HashSet 是如何保证不重复的 HashSet的底层实现结构是HashMap,它存放数据于HashMap的键中。而根据HashMap的特性，键是不允许重复的。 拓展： HashMap是以键值对存储数据的。它底层存放数据是数组+链表!每一个键，都有它相对应的唯一的hashcode码。当调用put方法放置一个key-value时，会获取键的hashcode，然后根据算法（h &amp; (length -1)），计算出应该存放的对应的数组块位置。如果多个hashcode计算出需要存放在同一数组块，则以链表的形式存储。 详情请看:HashMap的工作原理 3. HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）? HashMap是线程不安全的。hash碰撞和扩容的情况下会导致数据丢失或者形成闭环链表。 详情请看:HashMap为什么线程不安全(hash碰撞与扩容导致)、谈谈HashMap线程不安全的体现 4. HashMap 的扩容过程 计算当前数组的长度是否到最大值，如果到最大值，则修改阈值(2^31-1)之后，不会扩容 否则，初始化一个新的数组，将数据转移到新的数组里。 将新数组引用到hashmap里 修改阈值 拓展： HashMap初始容量为16，负载因子：0.75，即当前数组长度超过总长度的75%,则进行扩容。每次扩容为2的倍数。 数据转移过程（上接第二条） 遍历数组中的每一个元素 重新计算每个元素在数组中的位置 将元素放在数组上 访问下一个Entry链上的元素 1234567891011121314151617void transfer(Entry[] newTable) &#123; Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 Entry&lt;K, V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) &#123; src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do &#123; Entry&lt;K, V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 &#125; while (e != null); &#125; &#125; &#125; 详情请看：HashMap的扩容机制—resize() 5. HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？ JDK1.7中 使用一个Entry数组来存储数据，用key的hashcode取模来决定key会被放到数组里的位置，如果hashcode相同，或者hashcode取模后的结果相同（hash collision），那么这些key会被定位到Entry数组的同一个格子里，这些key会形成一个链表。在hashcode特别差的情况下，比方说所有key的hashcode都相同，这个链表可能会很长，那么put/get操作都可能需要遍历这个链表。也就是说时间复杂度在最差情况下会退化到O(n) 在扩容的时候，需要重新计算hashcode的值（hash collision），然后放到对应的数组格子里 JDK1.8中 使用一个Node数组来存储数据，但这个Node可能是链表结构，也可能是红黑树结构。如果插入的key的hashcode相同，那么这些key也会被定位到Node数组的同一个格子里。如果同一个格子里的key不超过8个，使用链表结构存储。如果超过了8个，那么会调用treeifyBin函数，将链表转换为红黑树。那么即使hashcode完全相同，由于红黑树的特点，查找某个特定元素，也只需要O(log n)的开销、也就是说put/get的操作的时间复杂度最差只有O(log n) 在扩容时候，可直接根据原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap” 详情请看：HashMap在Java1.7与1.8中的区别 6. final finally finalize final 是修饰符，关键字。被final修饰的类，就不能再派生新的子类，不能作为父类被子类继承，如String类。 finally是异常处理时，提供的finally块。不管是走try块还是catch块，都会执行finally块的代码。通常用来做清除操作或关闭流。 finalze是一个方法。java技术允许使用finalize（）方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。finalize（）方法是在垃圾收集器删除对象之前对这个对象调用的。 7. 强引用 、软引用、 弱引用、虚引用 强引用(Strong Reference),是最难被GC回收的，宁可虚拟机抛出异常，中断程序，也不回收强引用指向的实例对象。 软引用 (SoftReference)，在内存不足时，GC会回收软引用指向的对象 弱引用(WeakReference)，不管内存足不足，只要我GC,我都可能回收弱引用指向的对象 虚引用(PhantomReference )，该回收就回收，无所谓了，虚引用，我随便回收你，也叫幽灵引用，其实就是相当于没有指向任何实例对象 8. Java反射 在不用new的情况下，可以通过.class获取类中的方法和属性。 反射就是把java类中的各种成分映射成一个个的Java对象 9. Arrays.sort 实现原理和 Collection 实现原理 事实上Collections.sort方法底层就是调用的array.sort方法,Colletions.sort()实际会将list转为数组，然后调用Arrays.sort()，排完了再转回List。 JDK6里用的是快速排序，对于对象类型(Object[])，JDK6则使用归并排序 JDK7的进步到了JDK7，快速排序升级为双基准快排(双基准快排 vs 三路快排)；归并排序升级为归并排序的改进版TimSort，一个JDK的自我进化。 JDK8的进步再到了JDK8， 对大集合增加了Arrays.parallelSort()函数，使用fork-Join框架，充分利用多核，对大的集合进行切分然后再归并排序，而在小的连续片段里，依然使用TimSort与DualPivotQuickSort(双轴快排)。(TimSort算法就是找到已经排好序数据的子序列，然后对剩余部分排序，然后合并起来) 10. LinkedHashMap的应用 LinkedHashMap是HashMap的子类，它与HashMap的不同是HashMap是无序的，而LinkedHashMap维护着一个运行于所有条目的双重链接列表。 LinkedHashMap除了支持默认的插入顺序，还支持访问顺序。所谓访问顺序(access-order)是指在迭代遍历列表中的元素时最近访问的元素会排在LinkedHashMap的尾部 11. cloneable接口实现原理 Cloneable没有定义任何的接口方法，该接口在这里起到了一种标识的作用，表明实现它的类具备了实例拷贝功能。要想使一个类具备拷贝实例的功能，那么除了要重写Object类的clone()方法外，还必须要实现Cloneable接口 详情请看： JavaSE学习随笔（一） Cloneable接口源码分析与技术细节 12. 异常分类以及处理机制 Error是无法处理的异常，比如OutOfMemoryError（内存溢出），一般发生这种异常，JVM会选择终止程序。因此我们编写程序时不需要关心这类异常。 Exception也就是我们经常见到的一些异常情况，这些异常是我们可以处理的异常，是所有异常类的父类。 RuntimeException运行时异常 RuntimeNoException非运行时异常包括IOException、SQLException等 unchecked exception（非受查异常），包括Error和RuntimeException，比如常见的NullPointerException、IndexOutOfBoundsException。对于RuntimeException，java编译器不要求必须进行异常捕获处理或者抛出声明，由程序员自行决定。 checked exception（受查异常），也称非运行时异常（运行时异常以外的异常就是非运行时异常），由代码能力之外的因素导致的运行时错误。java编译器强制程序员必须进行捕获处理，比如常见的有IOExeption和SQLException。如果不进行捕获或者抛出声明处理，编译都不会通过。 处理：捕获机制：try-catch-finally 13. wait和sleep的区别 wait 休眠后会释放对象锁 sleep 休眠后不会释放对象锁 14. 数组在内存中如何分配 在堆内存中开辟一块空间，存放数组。在栈中添加引用。 本文题目提供：金三银四跳槽季，Java面试大纲 作者：占小狼]]></content>
      <categories>
        <category>java面试题</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--工厂模式]]></title>
    <url>%2F2018%2F04%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式：实现了创建者和调用者的分离 详细分类： 简单工厂模式 虽然某种程度不符合设计原则，但实际使用最多 工厂方法模式 不修改已有类的前提下，通过增加新的工厂类实现扩展。 抽象工厂模式 不可以增加产品。可以增加产品族。 应用场景 JDK中Calendar的getInstance方法 JDBC中Connection对象的获取 Hibernate中SessionFactory创建Session Spring中IOC容器创建管理bean对象 XML解析时DocumentBuilderFactory创建解析器对象 反射中Class对象的newInstance(); 面向对象的设计原则 OCP(开闭原则)：一个软件的实体应当对扩展开放，对修改关闭 DIP(依赖倒转原则)：要针对接口编程，不要针对现实编程 LOD(迪迷特法则)：只与你直接的朋友通信，而避免与陌生人通信 普通方法按照常理模式，当我们需要调用一个类的时候，我们需要通过new 一个对象来实现。那么，我在不知道工厂模式的情况下，多半是直接new，然后直接调用了。在此我就叫我的方法为普通方法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 定义Car接口 */public interface Car &#123; void run();&#125;/** * 实现Car接口 * 比亚迪 */public class Byd implements Car&#123; @Override public void run() &#123; System.out.println("比亚迪在跑"); &#125;&#125;/** * 实现Car接口 * 奥迪 */public class Audi implements Car&#123; @Override public void run() &#123; System.out.println("奥迪在跑"); &#125;&#125;/** * 使用普通方法调用比亚迪和奥迪类 * 结果： * 奥迪在跑 * 比亚迪再跑 */public class Client01 &#123; public static void main(String[] args) &#123; Car c1 = new Audi(); Car c2 = new Byd(); c1.run(); c2.run(); &#125;&#125; 该方法虽然简单，但是显然没有使用遵循面向对象设计的基本原则嘛。为了提高自我代码的质量，还是要学习设计模式，并在日常编程中运用。 简单工厂模式那么，要想提高，我们先来看一下简单工厂模式的类图： 如上图所示：和我们的简单方法是不是差了点什么？没错，我们缺少CarFactory类。那我们先来看下CarFactory和他的调用 1234567891011121314151617181920212223242526272829303132/** * 简单工厂类 * 缺点：不完全满足OCP */public class CarFactory &#123; public static Car getCar(String type)&#123; if ("奥迪".equals(type))&#123; return new Audi(); &#125;else if ("比亚迪".equals(type))&#123; return new Byd(); &#125;else &#123; return null; &#125; &#125;&#125;/** * 使用简单方法调用比亚迪和奥迪类 * 结果： * 奥迪在跑 * 比亚迪再跑 */public class Client02 &#123; public static void main(String[] args) &#123; Car c1 = CarFactory.getCar("奥迪"); Car c2 = CarFactory.getCar("比亚迪"); c1.run(); c2.run(); &#125;&#125; 在调用的时候，我们可以不必需要什么而new什么，我们只需要将参数传递过去，简单工厂会自动返回我们想要的对象。是不是灵活了很多！当然，这也就是所谓的找对象原则，我原先找对象，得自己找，苦苦的找，还不一定能找到。之后呢，出现这种找对象的平台了，我不用自己跑出去找了，我跟这个平台说一声，我想要长得好看的，个子高的，肤白貌美的。恩，这个平台就会给我找到。（ps:这个比喻忘记是看哪个仁兄的比喻，暂且借用。知道后标注。）这就是我们的工厂模式。 工厂方法模式看了简单工厂，我们来了解下工厂方法模式: 简单工厂模式只有一个工厂类，而工厂方法模式有一组实现了相同接口的工厂类。 对比简单工厂模式：增加了工厂接口，通过不同的工厂类来实现工厂模式。如下图所示： 对比简单模式，我们增加了一个工厂接口，然后实现不同的工厂，这个时候，我们的调用者Client不需要知道Car的接口，只需要知道Car工厂的接口，就可以调用。是不是更加深层次的解耦代码了。这样有什么好处呢，假如我使用简单工厂模式，在我增加一个产品的时候，比如，我增加宝马，那Car的工厂类得进行修改。而使用工厂方法模式，那么我们只需要增加一个宝马的工厂类就行。但是，这样也有一个缺点，就是文件太多，不利于管理。 抽象工厂模式 用来生产不同产品族的全部产品（对于增加的新的产品，无能为力；支持增加产品族） 抽象工厂模式是工厂方法模式的升级版本，在由多个业务品种，业务分类时，通过抽象工厂模式需要的对象是一种非常好的解决方式。 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础--反射]]></title>
    <url>%2F2018%2F03%2F26%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80--%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[什么是反射：java通常是先有类再有对象，有对象我就可以调用方法或者属性。反射其实是通过Class对象来调用类里面的方法。通过反射可以调用私有方法和私有属性。大部分框架都是运用反射原理。 反射的作用：动态的加载类和类中的信息 反射小例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384@SuppressWarnings("all")public class ReflexTestDemo &#123; public static void main(String[] args)&#123; String path = "com.tfs.test.User"; User user = new User(); try &#123; //一、获取对象的方式 Class&lt;User&gt; cl1 = (Class&lt;User&gt;) Class.forName(path); Class cl2 = User.class; Class cl3 = user.getClass(); System.out.println(cl1.hashCode() == cl2.hashCode()); //true System.out.println(cl1.hashCode() == cl3.hashCode()); //true //二、获取并使用对象内置信息 //1.获取名称 System.out.println(cl1.getName()); //com.tfs.test.User System.out.println(cl1.getSimpleName()); //User //2.获取并使用属性 Field[] fields = cl1.getFields(); //只能获取public的 Field[] fields1 = cl1.getDeclaredFields(); //获取全部的 Field field = cl1.getDeclaredField("name"); //根据名字获取 User u2 = cl1.newInstance(); //利用反射获取默认构造方法 field.setAccessible(true); //设置后可以不用进行安全检测，提高性能 field.set(u2,"kid"); //给name属性赋值kid System.out.println(field.get(u2)); //输出：kid //3.获取并使用普通方法 Method method = cl1.getDeclaredMethod("setName", String.class); //参数：方法名，方法参数 User u3 = cl1.newInstance(); method.invoke(u3,"kid"); //等同于 u3.setName("kid"); 方法 System.out.println(u3.getName()); //输出：kid //4.获取并使用构造方法 Constructor constructor1 = cl1.getDeclaredConstructor(); //获取无参构造方法 Constructor constructor2 = cl1.getDeclaredConstructor(int.class,String.class); //获取有参构造方法 User u4 = (User) constructor2.newInstance(1008,"kid"); //调用该方法并传参 System.out.println(u4.getName()); //输出：null 所以该方法只是调用了有参的构造函数，并未真正的传参 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;/** * @Description:被调用的User类 * @Author:kid * @Date: 2018/3/26 16:17 * @ISDELETE: NO */public class User &#123; public int id; String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public User()&#123; &#125; public User(int id,String name)&#123; &#125; 反射性能反射的会影响运行的速度，但是在开发中，有一些地方还是会需要反射。那么如何解决这个问题呢？经测验：在同时循环执行一个方法的时候，反射会比普通的方法慢很多。如将setAccessible设置为true，减少安全检测，将提升4倍的效率。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础--注解]]></title>
    <url>%2F2018%2F03%2F26%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80--%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解 什么叫做注解？注解-&gt;Annotation，JDK5.0引入技术 Annotation 的作用： 并不是程序本身，可以对程序作出解释。 可被其他程序读取（可做信息处理） 内置注解 @Override : 定义在java.lang.Override中，此注释只适用于修辞方法，表示一个方法声明打算重写父类中另一个方法声明。 @Deprecated：定义在java.lang.Deprecated中，此注释用于修辞方法、熟悉、类。表示不鼓励程序员使用这样的元素。 @SuppressWarnings：用来抑制编译时的警告信息。其中包含的参数： deprecation 使用了过时的类或方法的警告 unchecked 执行了未检查的转化时的警告，如使用集合时，未指定泛型 元注解（对注解进行进一步解释） @Target：用于描述注解的使用范围（如包、类、方法等） CONSTRUCTOR:用于描述构造器 FIELD:用于描述域 LOCAL_VARIABLE:用于描述局部变量 METHOD:用于描述方法 PACKAGE:用于描述包 PARAMETER:用于描述参数 TYPE:用于描述类、接口(包括注解类型) 或enum声明 @Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期 SOURCE:在源文件中有效（即源文件保留） CLASS:在class文件中有效（即class保留） RUNTIME:在运行时有效（即运行时保留） 自定义注解新建一个Annotation 方法，方法头加元注解，具体如下：12345678910111213141516@Target(value = ElementType.METHOD) //该注解只可放在方法前面@Retention(RetentionPolicy.RUNTIME) //可以通过反射读取到public @interface Annotation &#123; //定义参数默认值 String studentName() default ""; int age() default 0; int id() default -1; String[] schools() default &#123;&#125;;&#125;/* 引用该注解*/ @Annotation(age = 18,studentName = "二狗",id = 1008, schools = &#123;"北京大学","清华大学"&#125;) public void test()&#123; &#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>注解</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github博客搭建]]></title>
    <url>%2F2018%2F03%2F25%2F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%2Fgithub%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[最近看别人都搭建了属于自己的博客，心生羡慕。于是也抽空捣鼓一个。此次个人博客搭建是利用github平台搭建博客。下面主要讲述搭建过程及遇到的坑。 准备工作github到位在github官网上申请账号。记住注册的邮箱。在注册成功后，可以选择建一个项目。此次搭建一个公共的项目（私有的貌似得花钱）。注： 项目名称必须为你注册的名称加github.io，如我的项目名为 kid-297.github.io github需要和git建立连接，需要在本地生成ssh秘钥。如果在之前你有生成ssh公钥，那么就可以直接提交上去，如果没有，则需要填写邮箱以及密码进行生成（详情请看我文章 git配置） git到位众所周知，git是一个分布式版本控制系统。而我们此次项目的上传下载到github等工作，非他莫属。git的具体安装方式，请自行百度。 node.js到位据说node.js的功能很强大啊！但具体多强大我也不甚了解啊！至于在这安装node.js干嘛，主要是想用hexo啊！安装方式也不具体说了哈。 hexo到位使用hexo呢，主要是因为Hexo是一个开源的静态博客生成器。自带很多模板，可供广大网友自行选择。 hexo搭建过程 打开cmd并输入npm install -g hexo 在你要存放hexo的地方新建一个空文件夹名为hexo cmd安装完成之后右键打开Git bash（此时要求git已经安装好了） 在Git 的运行框中进入cd 进入hexo文件夹后输入$ hexo init 如果你按照上述步骤一套做完，那么恭喜你，hexo已经搭建成功，是不是很简单？ 本地运行hexo安装完hexo之后你就能在本地查看你的空hexo blog了在cmd中输入$ hexo s –debug（debug可以不写）随后你在浏览器地址栏输入http://localhost:4000/hexo默认主题landscape就呈现在你眼前了注：hexo s是hexo server的缩写 至此，本地的环境已经搭建完毕。可以考虑上传到github上或者给你的博客更换主题了。 提交至GitHub首先进入hexo文件夹，找到根目录下面的_config.yml文件,用编辑器打开它找到deploy。部署至GitHub需要填如下：1234deploy: type: git repository: git@github.com:kid-297/kid-297.github.io.git branch: master 注：.yml文件格式严格，在“：”之后一定要空格再输入，如果不填入内容则是默认值。文中kid-297请自行跟换成自己的用户名。 创建完成后打开Git bash按下ctrl+c并输入y结束hexo的本地预览。之后进入你的hexo文件夹，输入$ hexo generate（用于生成静态网页文件，可缩写成$ hexo g） 接着输入$ hexo deploy（可缩写成hexo d） 更改hexo主题如果你对hexo默认主题不满意，你也可以自己寻找主题包甚至是自己制作。具体使用方法请移步：hexo博客更换主题（原理一样，只是主题不同） 发布文章输入$ hexo new “博客名”创建成功之后，点击进入hexo文件夹的source文件夹，找到_posts文件夹，进入用编辑器打开你刚刚创建的.md文件，你将看到如下代码 title:date:tags: 在title后面填写文章名，注意空格，tags用来设置文章标签，格式为[标签一,标签二] 设置完之后就开始使用Markdown语法进行博客创作吧 文章写好后： hexo s 启动本地项目访问查看效果（http://localhost:4000/） hexo g 生成新的静态页面 hexo d 发布到github上去 其他常见的hexo命令 $ hexo clean #清除缓存 $ hexo generate –watch #监视文件变动 $ hexo new page “页面名” #新建页面 注 ： 本博客大部分出自于强大的hexo–如何利用hexo平台搭建个人博客 感谢作者，解我搭建之坑，特此记录！]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>博客</tag>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git配置]]></title>
    <url>%2F2018%2F03%2F25%2F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%2Fgit%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[如何配置git 生成并部署SSH key打开git bash,输入以下命令生成 SSH Keyssh-keygen -t rsa -C “xxxxx@xxxxx.com“ （该邮箱为Github/GitLab注册邮箱） 在相应的.ssh目录下会生成名为id_rsa私钥文件和id_rsa.pub公钥文件， 打开id_rsa.pub公钥文件,复制里面的公钥添加到Github/GitLab的添加SSH秘钥处。 然后在git bash中输入以下命令测试Github/GitLab的SSH秘钥是否部署成功。ssh -T git@github.com 出现以下提示，表示部署Github/GitLab的SSH key成功 Hi kid-297! You’ve successfully authenticated, but GitHub does not provide shell access. 如何配置多个git在工作和学习时候，难免会遇到一台电脑同时使用多个Github/GitLab的情况。下面讲述下如何配置多个。 如上已经配置生成好了一个公钥和私钥。我们在生成第二个或者更多个的时候，需要起不同的名字。不能再使用默认的文件名id_rsa， 否则会覆盖之前的gitLab的秘钥文件。 这里保存为id_rsa_work：ssh-keygen -t rsa -f ~/.ssh/id_rsa_work -C “xxxxx@xxxxx.com“ 这时候就会在.ssh目录下又生成一对公私钥文件,同样是打开公钥文件id_rsa_work .pub，复制里面的公钥添加到Github/GitLab SSH秘钥处。 添加秘钥到SSH Agent因为默认只读取id_rsa,为了让SSH识别新的私钥，需将其添加的SSH agent中。ssh-agent bashssh-add ~/.ssh/id_rsassh-add ~/.ssh/id_rsa_work 创建并配置config文件在.ssh目录下创建一个config文本文件,添加相关配置。每个账号单独配置一个Host，每个Host要取一个别名，每个Host主要配置HostName和IdentityFile两个属性即可。 我的配置12345678910111213141516# githubHost githubHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa# work githubhost gitlab#这个是真实的域名地址 HostName (此处填写GitLab的IP或者网址)#配置使用用户名User kid# 配置登录时用什么权限认证 可设为publickey,password publickey,keyboard-interactive等 PreferredAuthentications publickey#这里是id_rsa的地址IdentityFile ~/.ssh/id_rsa_work 这个时候再通过终端测试是否部署SSH Key成功 注：用户名和邮箱的配置因为一台电脑上配置了多个git账号，所以就不能再配置全局的用户名和邮箱了，而是在不同的仓库下，如果需要连接不同的git账号,配置相应的局部用户名和邮箱即可，如果之前配置过全局的用户名和邮箱,需要取消配置git config –global –unset user.namegit config –global –unset user.email 配置局部的用户名和邮箱git config user.name “xxxx”git config user.email “xxxx@xx.com“ 注：本博客大部分内容出自 windows下在一台电脑上配置多个git账号。感谢作者，解我搭建之坑，特此记录！]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--单例模式]]></title>
    <url>%2F2018%2F03%2F24%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[名词解析：GOF--&gt;Group Of Four 四人帮 设计模式共分为以下几种模式： 创建型模式： 单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式 结构型模式： 适配器模式、桥接模式、装饰者模式、组合模式、外观模式、享元模式、代理模式 行为模式： 模板方法模式 、命令模式、装饰模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式。状态模式、策略模式、职责链模式、访问者模式 核心作用保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。 常见的应用场景 windows的任务管理器、回收站 项目中的读取配置文件的类，数据库连接池，一般也只有一个对象。 应用程序中的日志应用、网站中的计数器 Applicathion和每个Servlet也是单例 Spring中，每个Bean也是单例的 Spring MVC框架/Struts框架中，控制对象也是单例 单例模式的优点 减少性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖方式时，则可以通过在应用中启动时直接产生一个单例对象，然后永久驻留在内存的方式来解决。 单例模式可以在系统中设置全局的访问点，优化共享资源访问 常见的5种单例模式实现方式： 主要： 饿汉模式（线程安全，调用率高。不能延时加载） 懒汉模式（线程安全，调用率低。可以延时加载） 其他： 双重检索锁式（由于JVM底层内部模型原因，偶尔会出现问题。不建议使用） 静态内部类式（线程安全、调用率高、可以延时加载） 枚举单例（线程安全、调用率高、不能延时加载） 饿汉模式（立即加载）1234567891011public class SingletonDemo1&#123; //1.实现私有的构造器，别人不可调用 private SingletonDemo1()&#123;&#125; //2.实现一个私有的对象。 类初始化时，立即加载这个对象！由于加载类时，天然的是线程安全的 private static SingletonDemo1 instance = new SingletonDemo1(); //3.提供一个开放方法。 方法没有同步，调用效率高 public static SingletonDemo1 getInstance()&#123; return instance; &#125;&#125; 问题：如果只是加载本类，但是没有调用getInstance方法， 则会造成资源浪费 懒汉模式(延迟加载/懒加载)1234567891011121314public class SingletonDemo2&#123; //1.实现私有的构造器，别人不可调用 private SingletonDemo2()&#123;&#125; //2.实现一个私有的对象。 类初始化时，不初始化这个对象！真正用的时候创建 private static SingletonDemo2 instance; //3.提供一个开放方法。 方法同步，调用效率低 public static synchronized SingletonDemo1 getInstance()&#123; if(instance == null)&#123; instance = new SingletonDemo2(); &#125; return instance; &#125;&#125; 问题：资源利用率高了，但是每次调用getInstance方法都需要同步，并发效率较低。 双重检索锁式123456789101112131415161718192021222324252627class SingletonDemo3 &#123; private static SingletonDemo3 instance = null; public static SingletonDemo3 getInstance() &#123; if (instance == null) &#123; SingletonDemo3 sc; synchronized (SingletonDemo3.class) &#123; sc = instance; if (sc == null) &#123; synchronized (SingletonDemo3.class) &#123; if(sc == null) &#123; sc = new SingletonDemo3(); &#125; &#125; instance = sc; &#125; &#125; &#125; return instance; &#125; private SingletonDemo3() &#123; &#125;&#125; 静态内部类123456789101112131415161718/** * 静态内部类式 * 线程安全、调用率高、可以延时加载 */class SingLetonStatic&#123; //定义静态内部类 private static class SingletonClassInstance&#123; private static final SingLetonStatic singLetonStatic = new SingLetonStatic(); &#125; private SingLetonStatic()&#123; &#125; public static SingLetonStatic getInstance()&#123; return SingletonClassInstance.singLetonStatic; &#125;&#125; 枚举12345678910111213/** * 枚举 * 线程安全、调用率高、不能延时加载 */enum SingLetonEnum&#123; //这个枚举元素，本身就是单例对象 INSTANCE; public void SingLetonEnumOp()&#123; &#125;&#125; 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web消息通讯方式--即时聊天]]></title>
    <url>%2F2018%2F03%2F21%2Fjava%20EE%2Fweb%E6%B6%88%E6%81%AF%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F-%E5%8D%B3%E6%97%B6%E8%81%8A%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[之前在一个项目中涉及到即时聊天功能，特此记录下当时的解决方法。 目前web上的消息通讯方式主要有以下几种。轮询，长连接，websocket 轮询：隔一段时间访问服务器，服务器不管有没有新消息都立刻返回。 长连接：页面向服务器发出请求，由服务器决定什么时候返回。（如果有新消息则立刻返回，没有的话就保持连接，直到有新消息才返回） websocket：类似Java Socket，由Http请求模拟实现的socket。 本次使用轮询方法做解决以下是轮询的代码：123456789101112131415161718192021222324252627 //返回未读json列 实现实时聊天 延迟1s //超时链处理 原则上和session保持一致 （例如session30分钟 180 000 毫秒） Integer sessionsec = 1800000; Integer sessionstop = 0; boolean isnewmess = false;//1.此处判断是否有新的聊天数据更新 if(isnewmess)&#123; // 返回消息内容 &#125;else&#123; //2.执行循环操作 while (isnewmess==false) &#123; //2.1 如果没有继续判断（节省服务器开销 进行休眠2 秒 为了保证实时性） sessionstop +=2000; if (sessionstop&gt;=sessionsec) &#123; isnewmess = true; //此处销毁链接 返回特征码 &#125;else&#123; Thread.sleep(1000); //此处判断是否有新的聊天数据更新 if (isnewmess) &#123; //返回消息内容 break; &#125; &#125; &#125; &#125;]]></content>
      <categories>
        <category>JAVA EE</category>
      </categories>
      <tags>
        <tag>即时聊天</tag>
      </tags>
  </entry>
</search>
