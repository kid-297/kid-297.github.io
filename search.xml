<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式GOF23--迭代器模式]]></title>
    <url>%2F2018%2F09%2F07%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[场景 提供一种可以遍历聚合对象的方式。又称为游标cursor模式 聚合对象：存储数据 迭代器：遍历数据 代码解析12345678910111213/** * 迭代器接口 */public interface MyIterator &#123; void first(); //将游标指向第一个元素 void next(); //将游标指向下一个元素 boolean hasNext(); //判断是否存在下一个元素 boolean isFirst(); boolean isLast(); Object getCurrentObj(); //获取当前游标指向对象&#125; 定义内部聚合类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 自定义的聚合类 */public class ConcrtetMyAggregate &#123; private List&lt;Object&gt; list = new ArrayList&lt;&gt;(); public ConcrtetMyAggregate() &#123; &#125; public void addObject(Object object)&#123; this.list.add(object); &#125; public void removeObject(Object obj)&#123; this.list.remove(obj); &#125; public List&lt;Object&gt; getList()&#123; return list; &#125; public void setList(List&lt;Object&gt; list)&#123; this.list = list; &#125; public MyIterator createIterator()&#123; return new ConcreteIterator(); &#125; //使用内部类定义迭代器，可以直接使用外部类的属性 private class ConcreteIterator implements MyIterator&#123; private int cursor; //定义游标用于记录遍历时的位置 @Override public void first() &#123; cursor = 0; &#125; @Override public void next() &#123; if (cursor&lt;list.size())&#123; cursor++; &#125; &#125; @Override public boolean hasNext() &#123; if (cursor&lt;list.size())&#123; return true; &#125; return false; &#125; @Override public boolean isFirst() &#123; return cursor==0?true:false; &#125; @Override public boolean isLast() &#123; return cursor==list.size()-1?true:false; &#125; @Override public Object getCurrentObj() &#123; return list.get(cursor); &#125; &#125;&#125; 调用1234567891011121314151617/** * 迭代器模式 */public class Client &#123; public static void main(String[] args) &#123; ConcrtetMyAggregate cma = new ConcrtetMyAggregate(); cma.addObject("aa"); cma.addObject("bb"); cma.addObject("cc"); MyIterator iterator = cma.createIterator(); while (iterator.hasNext())&#123; System.out.println(iterator.getCurrentObj()); iterator.next(); &#125; &#125;&#125; 基本案例 实现正向遍历的迭代器 实现逆向遍历的迭代器 开发中常见的场景 JDK内置的迭代器（List/Set）]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--责任链模式]]></title>
    <url>%2F2018%2F09%2F04%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义 将能够处理同一类请求的对象连成一条链，所提交的请求沿着链传递，链上的对象逐个判断是否有能力处理该请求，如果能则处理，如果不能则传递给链上的下一个对象。 场景 打牌时，轮流出牌 接力赛跑 大学中，奖学金审批 公司中，请假条审批 如果请假天数小于3天，主任审批 如果请假天数大于等于3天，小于10天，经理审批 如果大于等于10天，小于30天，总经理审批 如果大于等于30天，提示拒绝 代码解析（请假条审批）分装请假的基本信息1234567891011121314151617181920212223242526272829303132333435363738/** * 分装请假的基本信息 */public class LeaveRequest &#123; private String empName; private int leaveDays; private String reason; public String getEmpName() &#123; return empName; &#125; public void setEmpName(String empName) &#123; this.empName = empName; &#125; public int getLeaveDays() &#123; return leaveDays; &#125; public void setLeaveDays(int leaveDays) &#123; this.leaveDays = leaveDays; &#125; public String getReason() &#123; return reason; &#125; public void setReason(String reason) &#123; this.reason = reason; &#125; public LeaveRequest(String empName, int leaveDays, String reason) &#123; this.empName = empName; this.leaveDays = leaveDays; this.reason = reason; &#125;&#125; 抽象类12345678910111213141516171819202122/** * 抽象类 */public abstract class Leader &#123; protected String name; protected Leader nextLeader; //责任链上的后继模式 public Leader(String name) &#123; super(); this.name = name; &#125; //设定责任链上的后继对象 public void setNextLeader(Leader nextLeader) &#123; this.nextLeader = nextLeader; &#125; /** * 处理请求的核心方法 * @param request */ public abstract void handleRequest(LeaveRequest request);&#125; 领导具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 主任 */public class Director extends Leader &#123; public Director(String name) &#123; super(name); &#125; @Override public void handleRequest(LeaveRequest request) &#123; if(request.getLeaveDays()&lt;3)&#123; System.out.println("员工："+request.getEmpName()+"请假，天数："+request.getLeaveDays()+"，理由："+request.getReason()); System.out.println("主任："+this.name+",审批通过！"); &#125;else&#123; if(this.nextLeader != null)&#123; this.nextLeader.handleRequest(request); &#125; &#125; &#125;&#125;/** * 经理 */public class Manager extends Leader&#123; public Manager(String name) &#123; super(name); &#125; @Override public void handleRequest(LeaveRequest request) &#123; if(request.getLeaveDays()&lt;10)&#123; System.out.println("员工："+request.getEmpName()+"请假，天数："+request.getLeaveDays()+"，理由："+request.getReason()); System.out.println("经理："+this.name+",审批通过！"); &#125;else&#123; if(this.nextLeader != null)&#123; this.nextLeader.handleRequest(request); &#125; &#125; &#125;&#125;/** * 总经理 */public class GeneralManager extends Leader&#123; public GeneralManager(String name) &#123; super(name); &#125; @Override public void handleRequest(LeaveRequest request) &#123; if(request.getLeaveDays()&lt;30)&#123; System.out.println("员工："+request.getEmpName()+"请假，天数："+request.getLeaveDays()+"，理由："+request.getReason()); System.out.println("总经理："+this.name+",审批通过！"); &#125;else&#123; System.out.println("莫非"+request.getEmpName()+"不想干了？？？"); &#125; &#125;&#125; 调用123456789101112131415161718/** * 责任链模式 */public class Client &#123; public static void main(String[] args) &#123; Leader a = new Director("张三"); Leader b = new Manager("李四"); Leader c = new GeneralManager("王五"); //组织责任链关系 a.setNextLeader(b); b.setNextLeader(c); //开始请假操作 LeaveRequest request = new LeaveRequest("tom",10,"回家探亲"); a.handleRequest(request); &#125;&#125; 结果： 员工：tom请假，天数：10，理由：回家探亲 总经理：王五,审批通过！ 开发中常见的场景 Java中，异常机制就是一种责任链模式。一个try可以对应多个catch,当第一个catch不匹配类型，则自动跳到第二个catch javascript语言中，事件的冒泡和捕获机制。Java语言中，事件的处理采用观察者模式 Servlet开发中，过滤器的链式处理 Struts2中，拦截器的调用也时责任链模式 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--享元模式]]></title>
    <url>%2F2018%2F09%2F03%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[场景： 内存属性稀缺资源，不要随便浪费。如果有很多个完全相同或相似的对象，我们可以通过享元模式，节省内存。 核心 享元模式以共享的方式高效的支持大量细粒度对象的重用。 享元对象能做到共享的关键是区分了内部状态和外部状态。 内部状态：可以共享，不会随环境变化而改变 外部状态：不可以共享，会随环境变化而改变 享元模式实现： FlyweightFactory享元工厂类 创建并管理享元对象，享元池一般设计成键值对 FlyWeight抽象享元类 通常是一个接口或抽象类，声明公共方法，这些方法可以向外界提供对象的内部状态，设置外部状态。 ConcreteFlyWeight具体享元类 为内部状态提供成员变量进行存储 UnsharedConcreteFlyWright非共享享元类 不能被共享的子类可以设计为非共享享元类 模型图 代码解析（围棋案例）围棋棋子共有两种颜色，黑色和白色。他们的大小形状也都一样，唯一不一样的是他们所在棋盘的位置。那么，我们可以将它的颜色作为内部状态，将位置作为外部状态，模拟生成。 抽象享元类和具体享元类123456789101112131415161718192021222324252627282930313233343536/** * FlyWeight抽象享元类 */public interface ChessFlyWeight &#123; void setColor(String c); String getColor(); void display(Coordinate c);&#125;/** * ConcreteFlyWeight具体享元类 */class ConcreteChess implements ChessFlyWeight&#123; private String color; public ConcreteChess(String color) &#123; this.color = color; &#125; @Override public void setColor(String c) &#123; this.color = c; &#125; @Override public String getColor() &#123; return color; &#125; @Override public void display(Coordinate c) &#123; System.out.println("棋子颜色："+color); System.out.println("棋子位置:"+c.getX()+"==="+c.getY()); &#125;&#125; FlyweightFactory享元工厂类1234567891011121314151617/** * 享元工厂类 */public class ChessFlyWeightFactory &#123; //享元池对象 private static Map&lt;String,ChessFlyWeight&gt; map = new HashMap&lt;&gt;(); public static ChessFlyWeight getChess(String color)&#123; if(map.get(color)!= null)&#123; return map.get(color); &#125;else&#123; ChessFlyWeight cfw = new ConcreteChess(color); map.put(color,cfw); return cfw; &#125; &#125;&#125; UnsharedConcreteFlyWright非共享享元类123456789101112131415161718192021222324252627/** * 外部状态 */public class Coordinate &#123; private int x,y; public Coordinate(int x, int y) &#123; this.x = x; this.y = y; &#125; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getY() &#123; return y; &#125; public void setY(int y) &#123; this.y = y; &#125;&#125; 调用12345678910111213public class Client &#123; public static void main(String[] args) &#123; ChessFlyWeight chessFlyWeight1 = ChessFlyWeightFactory.getChess("黑色"); ChessFlyWeight chessFlyWeight2 = ChessFlyWeightFactory.getChess("黑色"); System.out.println(chessFlyWeight1); System.out.println(chessFlyWeight2); System.out.println("增加外部状态的处理============"); chessFlyWeight1.display(new Coordinate(10,10)); chessFlyWeight2.display(new Coordinate(20,20)); &#125;&#125; 结果： com.kid.flyweight.ConcreteChess@4554617c com.kid.flyweight.ConcreteChess@4554617c 增加外部状态的处理============ 棋子颜色：黑色 棋子位置:10============10 棋子颜色：黑色 棋子位置:20============20 享元模式开发中应用的场景： 享元模式由于其共享的特性，可以在任何池中操作，比如：线程池、数据库连接池。 String类的设计也是享元模式 优点 极大减少内存中对象的数量 相同或相似的对象内存中只存在一份，极大的节约资源，提高系统性能 外部状态相对独立，不影响内部状态 缺点 模式较复杂，是程序逻辑复杂化 为了节省内存，共享了内部状态，分离出外部状态，而读取外部状态使运行时间边长。用时间换取了空间。 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--外观模式]]></title>
    <url>%2F2018%2F09%2F01%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[迪米特法则（最少知识原则） 一个软件实体应当尽可能少的与其他实体发生相互作用 外观模式的核心 为子系统提供统一的入口，封装子系统的复杂性，便于客户端被调用。 基本案例（泡茶流程代码解析）准备必要工具（茶具、茶叶、水、喝茶的人）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/** * 茶具接口 */public interface TeaSet &#123; void useTeaSet();&#125;class CoveredTeaSet implements TeaSet&#123; @Override public void useTeaSet() &#123; System.out.println("使用盖碗茶具"); &#125;&#125;class FlowerReceptacle implements TeaSet&#123; @Override public void useTeaSet() &#123; System.out.println("使用玻璃杯"); &#125;&#125;class DarkRedEnameledPottery implements TeaSet&#123; @Override public void useTeaSet() &#123; System.out.println("使用紫砂壶"); &#125;&#125;/** * 茶叶 */public interface Tea &#123; void useTea();&#125;class BiluochunTea implements Tea&#123; @Override public void useTea() &#123; System.out.println("使用碧螺春"); &#125;&#125;class JasmineTea implements Tea&#123; @Override public void useTea() &#123; System.out.println("使用茉莉花茶"); &#125;&#125;class PuerTea implements Tea&#123; @Override public void useTea() &#123; System.out.println("使用普洱"); &#125;&#125;/** * 水 */public interface Water &#123; void useWater();&#125;class BoilingWater80 implements Water&#123; @Override public void useWater() &#123; System.out.println("使用80度开水"); &#125;&#125;class BoilingWater90 implements Water&#123; @Override public void useWater() &#123; System.out.println("使用90度开水"); &#125;&#125;class BoilingWater100 implements Water&#123; @Override public void useWater() &#123; System.out.println("使用100度开水"); &#125;&#125;/** * 人 */public class People &#123; String name; public People(String name) &#123; this.name = name; &#125; public People() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 使用非外观者模式自己泡茶12345678910111213141516171819/** * 外观模式 调用者 */public class Client &#123; public static void main(String[] args) &#123; /** * 使用非外观者模式 泡茶 */ People huangYaoShi = new People("黄药师"); TeaSet darkRedEnameledPottery = new DarkRedEnameledPottery(); darkRedEnameledPottery.useTeaSet(); Tea puerTea = new PuerTea(); puerTea.useTea(); Water boilingWater100 = new BoilingWater100(); boilingWater100.useWater(); System.out.println(huangYaoShi.getName()+"自己泡茶"); &#125;&#125; 结果： 使用紫砂壶 使用普洱 使用100度开水 黄药师自己泡茶 由上可以看出自己泡茶需要调用的东西极多，颇为复杂。 使用外观者模式茶馆喝茶1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 泡茶流程的门面对象（茶馆） */public class MakeTea &#123; public void make(String teaName,String username)&#123; TeaSet teaSet = null; Tea tea = null; Water water = null; switch (teaName)&#123; case "puer": teaSet = new DarkRedEnameledPottery(); teaSet.useTeaSet(); tea = new PuerTea(); tea.useTea(); water = new BoilingWater100(); water.useWater(); System.out.println("为"+username+"泡茶"); break; case "biluochun": teaSet = new CoveredTeaSet(); teaSet.useTeaSet(); tea = new BiluochunTea(); tea.useTea(); water = new BoilingWater80(); water.useWater(); System.out.println("为"+username+"泡茶"); break; case "jasmine": teaSet = new FlowerReceptacle(); teaSet.useTeaSet(); tea = new JasmineTea(); tea.useTea(); water = new BoilingWater90(); water.useWater(); System.out.println("为"+username+"泡茶"); break; default: this.make("jasmine",username); break; &#125; &#125;&#125;/** * 外观模式 调用者 */public class Client &#123; public static void main(String[] args) &#123; /** * 使用外观者模式泡茶 */ MakeTea makeTea = new MakeTea(); People ouyangfeng = new People("欧阳锋"); makeTea.make("biluochun",ouyangfeng.getName()); &#125;&#125; 结果： 使用盖碗茶具 使用碧螺春 使用80度开水 为欧阳锋泡茶 所以，自己泡茶还是茶馆喝茶，你，选择好了吗？ 开发中常用的场景 频率很高。哪里都会遇到。各种技术和框架中，都有外观模式的使用。如： JDBC封装后，commons提供的DBUtils类，Hibernate提供的工具类、Spring JDBC工具类等。 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--装饰模式]]></title>
    <url>%2F2018%2F09%2F01%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[职责 动态的为一个对象增加新的功能 装饰模式是一种用于代替继承的技术，无须通过继承增加子类就能扩展对象的新功能。使对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。 实现细节 Component抽象构建角色 真实对象和装饰对象有相同的接口，这样，客户端对象就能够以真实对象相同的方式装饰对象交互。io流中的InputStream、OutputStream、Reader、Writer ContreteComponent具体构建角色（真实对象）： io流中的FileInputStream、FileOutputStream Decorator装饰角色： 持有一个抽象构建的引用。装饰对象接受所有客户端的请求，并把这些请求转发给真实的对象，这样，就能在真实对象的调用前后增加新的功能。io流中的FilterInputStream、FilterOutputStream CpncreteDecorator具体装饰角色： 负责给构件对象增加新的责任。io流中的BufferedOutputStream、BufferedInputStream等 模拟汽车多种模式抽象组件Component123456/** * 抽象组件 */public interface ICar &#123; void move();&#125; 具体构件对象ContreteComponent123456789/** * 具体构件对象 */class Car implements ICar&#123; @Override public void move() &#123; System.out.println("陆地上跑"); &#125;&#125; 装饰器角色 Decorator12345678910class SuperCar implements ICar&#123; protected ICar car; public SuperCar(ICar car) &#123; this.car = car; &#125; @Override public void move() &#123; car.move(); &#125;&#125; 具体装饰对象CpncreteDecorator1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 具体装饰对象 天上飞类型 */class FlyCar extends SuperCar &#123; public FlyCar(ICar car) &#123; super(car); &#125; @Override public void move() &#123; super.move(); fly(); &#125; public void fly()&#123; System.out.println("天上飞"); &#125;&#125;/** * 具体装饰对象 水上游类型 */class WaterCar extends SuperCar &#123; public WaterCar(ICar car) &#123; super(car); &#125; @Override public void move() &#123; super.move(); swim(); &#125; public void swim()&#123; System.out.println("水上游"); &#125;&#125;/** * 具体装饰对象 自动跑类型 */class AICar extends SuperCar &#123; public AICar(ICar car) &#123; super(car); &#125; @Override public void move() &#123; super.move(); autoMove(); &#125; public void autoMove()&#123; System.out.println("自动跑"); &#125;&#125; 调用12345678910111213141516171819202122/** *装饰器模式 */public class Client &#123; public static void main(String[] args) &#123; System.out.println("=============汽车功能============"); Car car = new Car(); car.move(); System.out.println("=============增加功能，飞行============"); FlyCar flyCar = new FlyCar(car); flyCar.move(); System.out.println("=============增加功能，水里游============"); WaterCar waterCar = new WaterCar(car); waterCar.move(); System.out.println("=============增加功能，飞行，水里游============"); WaterCar waterCar1 = new WaterCar(new FlyCar(car)); waterCar1.move(); &#125;&#125; 结果结果： =============汽车功能============ 陆地上跑 =============增加功能，飞行============ 陆地上跑 天上飞 =============增加功能，水里游============ 陆地上跑 水上游 =============增加功能，飞行，水里游============ 陆地上跑 天上飞 水上游 开发中使用的场景： IO中输入流和输出流的设计 Swing包中图形界面构件功能 Servlet API中提供了一个request对象的Decorator设计模式的默认实现类HttpServerRequestWrapper,HttpServletRequestWrapper类，增强了request对象的功能 Struts2中，request，response,session对象的处理 总结 装饰模式（Decorator）也叫包装器模式（Wrapper） 装饰模式降低系统的耦合度，可以动态的增加或删除对象的职责，并使得需要装饰的具体构建类和具体装饰类可以独立变化，以便增加新的具体构建类和具体装饰类 优点 扩展对象功能，比继承灵活，不会导致类个数急剧增加 可以对一个对象进行多次装饰，创造出不同行为的组合，得到功能更强大的对象 具体构建类和具体装饰类可以独立变化，用户可以根据需要自己增加新的具体构件子类和具体装饰子类 缺点 产生很多小对象。大量的小对象占据内存，一定程度上影响性能。 装饰模式易于出错，调试排查比较麻烦 装饰模式和桥接模式的区别 两个模式都是为了解决过多的子类对象问题。但是他们的诱因不一样。桥接模式是对象自身现有机制沿着多个维度变化，是既有部分不稳定。装饰模式是为了增加新的功能 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--组合模式]]></title>
    <url>%2F2018%2F08%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[使用组合模式的场景 把部分和整体的关系用树形结构来表示，从而使客户端可以使用统一的方式处理部分对象和整体对象。 组合模式的核心 抽象构建（Component）角色：定义了叶子和容器构件的共同点 叶子（Leaf）构件角色：无子节点 容器（Composite）构件角色：有容器特征，可以包含子节点 12345678910111213141516171819202122/** * 抽象组件 */public interface Component &#123; void operation();&#125;/** * 叶子组件 */interface Leaf extends Component&#123;&#125;/** * 容器组件 */interface Composite extends Component&#123; void add(Component c); void remove(Component c); Component getChild(int index);&#125; 组合模式工作流程分析 组合模式为处理树形结构提供了完美的解决方案，描述了如何将容器和叶子进行递归组合，使得用户在使用时可以一致性的对待容器和叶子。 当容器对象的指定方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员，并调用执行。其中，使用了递归的机制对整个结构进行处理。 使用组合模式，模拟杀毒软件架构设计下面，我们使用组合模式，来模拟杀毒过程。我们先定义抽象组件，定义其共同点。其次，我们定义叶子节点（图片文件、文本文件、视频文件）。之后，我们定义容器组件（文件夹）。容器组件中，我们使用递归方法进行查杀，直到叶子节点查杀完毕。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * 抽象组件 */public interface AbstractFile &#123; void killVirus();&#125;/** * 叶子组件 图片文件 */class ImageFile implements AbstractFile&#123; private String name; public ImageFile(String name) &#123; super(); this.name = name; &#125; @Override public void killVirus() &#123; System.out.println("--图片文件："+name+"进行查杀"); &#125;&#125;/** * 叶子组件 文本文件 */class TextFile implements AbstractFile&#123; private String name; public TextFile(String name) &#123; super(); this.name = name; &#125; @Override public void killVirus() &#123; System.out.println("--文本文件："+name+"进行查杀"); &#125;&#125;/** * 叶子组件 视频文件 */class VideoFile implements AbstractFile&#123; private String name; public VideoFile(String name) &#123; super(); this.name = name; &#125; @Override public void killVirus() &#123; System.out.println("--视频文件："+name+"进行查杀"); &#125;&#125;/** * 容器组件 */class Folder implements AbstractFile&#123; private String name; //定义容器，用来存放本容器构建下的子节点 private List&lt;AbstractFile&gt; list = new ArrayList&lt;&gt;(); public Folder(String name) &#123; this.name = name; &#125; public void add(AbstractFile abstractFile)&#123; list.add(abstractFile); &#125; public void romove(AbstractFile abstractFile)&#123; list.remove(abstractFile); &#125; public AbstractFile getChile(int index)&#123; return list.get(index); &#125; @Override public void killVirus() &#123; System.out.println("==文件夹："+name+"进行查杀"); for (AbstractFile file: list) &#123; file.killVirus(); &#125; &#125;&#125; 调用执行：模拟文件夹存放模式，在文件夹我的收藏里存放一个图像，一个文本，一个电影文件夹，在电影文件夹中，我们存放两个视频文件。模拟查杀模式。我们只需调用我的收藏进行查杀，其下包括其都将进行查杀。 1234567891011121314151617181920public class Client &#123; public static void main(String[] args) &#123; AbstractFile f2,f3,f4,f5,f6; Folder f1 = new Folder("我的收藏"); f2 = new ImageFile("头像.jpg"); f3 = new TextFile("Hello.txt"); f1.add(f2); f1.add(f3); // f1.killVirus(); Folder f11 = new Folder("电影"); f4 = new VideoFile("笑傲江湖.avi"); f5 = new VideoFile("神雕侠侣.avi"); f11.add(f4); f11.add(f5); f1.add(f11); f1.killVirus(); &#125;&#125; 结果： ==文件夹：我的收藏进行查杀 --图片文件：头像.jpg进行查杀 --文本文件：Hello.txt进行查杀 ==文件夹：电影进行查杀 --视频文件：笑傲江湖.avi进行查杀 --视频文件：神雕侠侣.avi进行查杀 开发中的应用场景： 操作系统的资源管理器 GUI中的容器层次图 XML文件解析 OA系统中，组织结构的处理 Junit单元测试框架 底层设计就是典型的组合模式，TestCase（叶子）、TestUnit(容器)、Test接口（抽象） 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--桥接模式]]></title>
    <url>%2F2018%2F08%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[场景 商城系统中常见的商品分类，以电脑为类，如何良好的处理商品分类销售的问题？如图所示，我们的电脑有很多的品牌，如联想，戴尔等。同时，我们的电脑有很多的品类，如台式机，笔记本，平板电脑等。那么，我们组合展示电脑的时候，我们一般会使用多层继承结构实现图中关系： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.kid.bridge;public interface Computer &#123; void sale();&#125;class Desktop implements Computer&#123; @Override public void sale() &#123; System.out.println("销售台式机"); &#125;&#125;class Laptop implements Computer&#123; @Override public void sale() &#123; System.out.println("销售笔记本"); &#125;&#125;class LenovoDesktop extends Desktop&#123; @Override public void sale() &#123; System.out.println("销售联想台式机"); &#125;&#125;class LenovoLaptop extends Laptop&#123; @Override public void sale() &#123; System.out.println("销售联想笔记本"); &#125;&#125;class DellDesktop extends Desktop&#123; @Override public void sale() &#123; System.out.println("销售戴尔台式机"); &#125;&#125;class DellLaptop extends Laptop&#123; @Override public void sale() &#123; System.out.println("销售戴尔笔记本"); &#125;&#125; 一件商品的展示，我们需要耗费很大的时间。就有如下问题发生： 扩展性问题： 如果要增加一个新的电脑类型，平板电脑，则要怎加各个品牌下面的类。 如果要增加一个新的品牌，也要增加各种电脑类型的类。 违反单一职责原则： 一个类：联想笔记本，有两个引起这个类变化的原因 场景分析 这个场景中有两个变化的维度：电脑类型、电脑品牌。那么，我们可以建立两个不同的维度，通过某些连接，使其两两不同组合。– &gt; 桥接模式 桥接模式的核心要点 处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。 代码解析我们先建造电脑品牌维度1234567891011121314151617181920212223/** * 电脑品牌维度 */public interface Brand &#123; void sale();&#125;class Lenovo implements Brand&#123; @Override public void sale() &#123; System.out.println("销售联想电脑"); &#125;&#125;class Dell implements Brand&#123; @Override public void sale() &#123; System.out.println("销售戴尔电脑"); &#125;&#125; 再建造电脑类型维度1234567891011121314151617181920212223242526272829303132333435363738394041/** * 电脑类型维度 */public class Computer2 &#123; protected Brand brand; public Computer2(Brand brand) &#123; this.brand = brand; &#125; public void sale()&#123; brand.sale(); &#125;&#125;class Desktop2 extends Computer2&#123; public Desktop2(Brand brand) &#123; super(brand); &#125; @Override public void sale() &#123; super.sale(); System.out.println("销售台式机"); &#125;&#125;class Laptop2 extends Computer2&#123; public Laptop2(Brand brand) &#123; super(brand); &#125; @Override public void sale() &#123; super.sale(); System.out.println("销售笔记本"); &#125;&#125; 调用：12345678910/** * 桥接模式 */public class Client &#123; public static void main(String[] args) &#123; //销售联想笔记本电脑 Computer2 c = new Laptop2(new Lenovo()); c.sale(); &#125;&#125; 这样，我们就很轻松的实现业务需求。即使增加新的品类或者品牌。也只需要增加部分代码就可以，而无需改动太多。 桥接模式实际开发中应用场景 JDBC驱动程序 AWT中的Peer架构 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--代理模式]]></title>
    <url>%2F2018%2F08%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代理模式（proxy pattern） 核心作用 通过代理，控制对对象的访问可以详细控制访问某个（某类）对象的方法，在调用这个方法浅做前置处理，调用这个方法后做后置处理。（即：AOP的微观实现） AOP（Aspect Oriented Programming 面向切面编程）的核心实现机制 核心角色 抽象角色 定义代理角色和真实角色的公共对外方法 真实角色 实现抽象角色，定义真实角色所需要实现的业务逻辑，供代理角色调用 关注真正的业务逻辑 代理角色 实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。 将统一的流程控制放到代理角色中处理！ 安全场景 安全代理：屏蔽对真实角色的直接访问 远程代理：通过代理类处理远程方法调用（RMI） 延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象。 分类 静态代理（静态定义代理类） 动态代理（动态生成代理类） jdk自带的动态代理 javaassist字节码操作库是实现 CGLIB ASM（底层使用指令，可维护性较差） 代码解析我们用现实生活中的明星和经纪人举个例子：建一个明星接口，代表明星日常所需要做的事情。1234567891011121314151617181920212223242526public interface Star &#123; /** * 面谈 */ void confer(); /** * 签合同 */ void signContract(); /** * 订票 */ void bookTickect(); /** * 唱歌 */ void sing(); /** * 收钱 */ void collectMoney();&#125; 然后我们实现一下接口，构建一个“真实”的明星1234567891011121314151617181920212223242526272829/** *真实角色 */public class RealStar implements Star&#123; @Override public void confer() &#123; System.out.println("RealStar.confer()"); &#125; @Override public void signContract() &#123; System.out.println("RealStar.signContract()"); &#125; @Override public void bookTickect() &#123; System.out.println("RealStar.bookTickect()"); &#125; @Override public void sing() &#123; System.out.println("RealStar（周杰伦本人）.sing()"); &#125; @Override public void collectMoney() &#123; System.out.println("RealStar.collectMoney()"); &#125;&#125; 静态代理在静态代理中，我们需要一个专门的代理类，去实现明星接口，代替明星完成一些事情，那么我们看一下明星日常需要完成的类，只有唱歌，是需要本人完成，其他的事情都可以由经纪人代理。那么，我们就只需要在sing()方法里调用真实唱歌类就可以了。123456789101112131415161718192021222324252627282930313233343536/** * 代理人 */public class ProxyStar implements Star&#123; private Star star; @Override public void confer() &#123; System.out.println("ProxyStar.confer()"); &#125; @Override public void signContract() &#123; System.out.println("ProxyStar.signContract()"); &#125; @Override public void bookTickect() &#123; System.out.println("ProxyStar.bookTickect()"); &#125; @Override public void sing() &#123; star.sing(); &#125; @Override public void collectMoney() &#123; System.out.println("ProxyStar.collectMoney()"); &#125; public ProxyStar(Star star) &#123; super(); this.star = star; &#125;&#125; 我们调用一下代理方法，来看下效果：12345678910111213141516/** * 静态代理（我们自己定义代理） */public class Client &#123; public static void main(String[] args) &#123; Star real = new RealStar(); Star proxy = new ProxyStar(real); proxy.confer(); proxy.signContract(); proxy.bookTickect(); proxy.sing(); proxy.collectMoney(); &#125;&#125; 结果： ProxyStar.confer() ProxyStar.signContract() ProxyStar.bookTickect() RealStar（周杰伦本人）.sing() ProxyStar.collectMoney() 动态代理我们在来看下动态代理,和静态代理不同，我们只需要实现InvocationHandler接口，重写invoke()方法就可实现代理。12345678910111213141516171819202122232425262728import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;/** * 核心 */public class StarHandler implements InvocationHandler &#123; Star realStar; public StarHandler(Star realStar) &#123; super(); this.realStar = realStar; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object object = null; System.out.println("真正的方法执行前！"); //调用方法 此处简化 System.out.println("面谈，签合同，订票"); if(method.getName().equals("sing"))&#123; object = method.invoke(realStar,args); &#125; System.out.println("真正的方法执行后！"); System.out.println("收尾款"); return object; &#125;&#125; 同样，我们调用一下方法，看下结果：12345678910111213import java.lang.reflect.Proxy;/** * 动态代理 */public class Client &#123; public static void main(String[] args) &#123; Star realStar = new RealStar(); StarHandler handler = new StarHandler(realStar); Star proxy = (Star) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]&#123;Star.class&#125;,handler); proxy.sing(); &#125;&#125; 结果： 真正的方法执行前！ 面谈，签合同，订票 RealStar（周杰伦本人）.sing() 真正的方法执行后！ 收尾款 同样的，我们实现了代理。 动态代理相比于静态代理的优点 抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法处理，这样，我们可以更加灵活和统一的处理众多的方法。 JDK自带的动态代理 java.lang.reflect.Proxy 作用：动态生成代理类和对象 java.lang.reflect.InvocationHandler(处理器接口) 可以通过invoke方法实现对真实角色的代理访问 每次通过Proxy身材代理类对象时都要指定对应的处理器对象 开发框架中应用场景 struts2中拦截器的实现 数据库连接池关闭处理 Hibernate中延时加载的实现 mybatis中实现拦截器插件 AspectJ的实现 spring中AOP的实现 日志拦截 声明式事务处理 web service RMI远程方法调用 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--适配器模式]]></title>
    <url>%2F2018%2F08%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是适配器模式 将一个类的接口转换成客户希望的另外一个接口。adapter就是将原本由于接口不兼容而不能一起工作的类可以在一起工作。 模式中的角色 目标接口（target）:客户所期待的接口，目标可以是具体的或者抽象的类，也可以是接口 需要适配的类（adaptee）：需要适配的类或适配者类 适配器（adapter）:通过报纸一个需要的适配的对象，把原接口转换成目标接口。 实例解析我们日常生活中用到适配器的情况其实很多，比如说，我们有一个可以适配台式机的键盘（PS/2），当我们想同样用在笔记本电脑上（USB），那我们就需要一个转接器，这个时候，我们的目标接口就是笔记本电脑(USB接口)，而我们需要适配的类就是键盘（PS/2）,适配器就是我们的转接器。下面，我们来用代码解析一下。 代码解析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 目标接口 * USB */public interface Target &#123; void handleRequest();&#125;/** * 需要适配的类 * （相当于例子中的，PS/2键盘） */public class Adaptee &#123; public void request()&#123; System.out.println("可以实现客户需求功能 "); &#125;&#125;/** * 适配器 * （相当于user和ps/2转接器） */public class Adapter implements Target&#123; private Adaptee adaptee; @Override public void handleRequest() &#123; adaptee.request(); &#125; public Adapter(Adaptee adaptee) &#123; super(); this.adaptee = adaptee; &#125;&#125;/** * 客户端类 * （相当于例子中的笔记本，只有USB接口） */public class Client &#123; public void test1 (Target t)&#123; t.handleRequest(); &#125; public static void main(String[] args) &#123; Client c = new Client(); Adaptee a = new Adaptee(); Target t = new Adapter(a); t.handleRequest(); &#125;&#125; 工作中的场景 经常用来做旧系统改造和升级 如果我们的系统开发后再也不需要维护，那么很多模式都是没必要的，但不幸的是，事实确实维护一个系统的代价往往是开发一个系统的数倍 我们学习中见过的场景 java.io.InputStreamReader(InputStream) java.io.OutputStreamWriter(OutputStream) 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一路走来]]></title>
    <url>%2F2018%2F08%2F17%2F%E9%9A%8F%E4%BE%BF%E5%8F%A8%E5%8F%A8%2F%E4%B8%80%E8%B7%AF%E8%B5%B0%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[初入坑2013年夏，糊里糊涂的就选了计算机专业，这对于高中计算机课作业都头疼的人来说，绝不是一个好的消息。颓废度日或许是日后的选择。“无奈”初入校门的第一堂C语言课，就遇到系里“有名”的严格老师。“被迫”之下，愉快的开始了编程史~~ 负增长过了初始敲出一段代码，兴奋到不行的阶段，兴趣开始负增长。仅剩下的一点学习的动力，大概也是为了获取给同学解决bug，被称赞时的荣耀感。 初入行怀揣着学校里获取的荣耀感，打算“大杀四方”，却无奈妥协，却依然未认清自己。没有了学校里的被动学习状态，简直是放飞自我。而且一再的自我感觉良好。直到，之前以为“志同道合”的小伙伴获取了一份不错的offer。决定开始自主学习。 拖延症+焦虑症了解的越多，才知道自己懂的太少。焦虑症病发，伴随着拖延症接踵而来。想学习，需要学的东西太多，先学什么？如同瞎子摸鱼。之后就不了了之。 觉悟季+打卡季另一个志同道合的小伙伴也走了，去寻找更好的未来。开始有些觉悟，决心踏踏实实沉下心来，一步一步走。利用空闲时间，学东西，撸代码，写博客。 代码之悟越来越开始注重代码的质量，写一段好的代码，就如同写一份优雅文章。 博客之悟 从刚开始的不会就百度，之后就忘记。 到后来的百度后记录，却知其然不知其所以然。 再之后，知其然，也之其所以然，却仅仅只是知道，却无法完美的表述。看似自己写的博客，面面俱到，却只是徒有其表。 之后目标，一篇好的文章，需要字字斟酌，浅显易懂。不仅要让自己看懂，也要让别人看懂。 未来之路希望志同道合的小伙伴们会一直志同道合，而不是在某个瞬间，被甩远，到最后，只剩下仰望。 To Lao Wang , Lao Nan]]></content>
      <categories>
        <category>随便叨叨</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--原型模式]]></title>
    <url>%2F2018%2F08%2F17%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[what is the prototype model(原型模式是什么)？ 用原型实例制定创建的对象的种类，并且通过拷贝这些原型创建新的对象 就是通过JAVA的克隆技术，以某个对象为原型，复制出新的对象。显然，新的对象具备原型对象的特点 克隆类似于new，但是不同于new。new创建的对象属性采用的是默认值。克隆出的对象属性值于原型对象相同。并且克隆出的新对象改变不会影响原型对象。然后，再修改克隆对象的值。 Why use prototype mode（为什么要用原型模式）? 通过new产生的一个对象需要非常繁琐的数据准备或访问权限，则可以用原型模式。 优势有：效率高（直接克隆，避免了重新构造过程的步骤） 浅复制和深复制浅复制和深复制是个什么鬼？憋说话，我们先上代码。 浅复制代码解析我们先来建一个羊的实体类，属性包括名称和出生日期。如果想实现克隆（复制），我们需要实现Cloneable接口。重写他的clone方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Sheep implements Cloneable&#123; private String sname; private Date birthday; public String getSname() &#123; return sname; &#125; public void setSname(String sname) &#123; this.sname = sname; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; Object obj = super.clone(); return obj; &#125; public Sheep(String sname, Date birthday) &#123; this.sname = sname; this.birthday = birthday; &#125; public Sheep() &#123; &#125;&#125;```` 我们来测试一下，实例化两个羊，我们来看看不同。（如果没有原型模式，那我们多半会直接new 两个Sheep，这样确实可以实现需求，可是，就考虑代码性能方面来看，每次调用构造方法，都会造成大量的资源耗损，那么，我们来试试传说中的原型模式）使用clone()方法，我们来构建s2(第二只羊)。然后将他们的属性都打印出来。````java/** * 测试原型模式(浅克隆) * 克隆分（深克隆和浅克隆） */public class Client &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Date date = new Date(234234234234L); Sheep s1 = new Sheep("小羊",date); Sheep s2 = (Sheep) s1.clone(); System.out.println(s1); System.out.println(s1.getSname()); System.out.println(s1.getBirthday()); date.setTime(123123132L); System.out.println(s1.getBirthday()); s2.setSname("大羊"); System.out.println(s2); System.out.println(s2.getSname()); System.out.println(s2.getBirthday()); &#125;&#125; 结果： com.kid.prototype.Sheep@4554617c 小羊 Sat Jun 04 09:03:54 CST 1977 Fri Jan 02 18:12:03 CST 1970 com.kid.prototype.Sheep@7f31245a 大羊 Fri Jan 02 18:12:03 CST 1970 分析结果，可以发现 s1和s2是两个不同的实体类。而且我们在克隆s2之后，改变其sname参数的值，也没有影响到原模型的参数。但是！我们发现我们在改变s1的date参数的时候，直接影响到了s2的结果。那么就涉及到之前所提的深复制浅复制了。 深复制浅复制解析 浅复制：当原型对象被复制时，只复制它本身和其中包含的值类型的成员变量，而引用类型的成员变量并没有复制。 深复制：在计算机中开辟了一块新的内存地址用于存放复制的对象。 深复制和浅复制最根本的区别在于是否是真正获取了一个对象的复制实体，而不是引用。 深复制代码解析我们将实体类中的clone方法重写12345678@Overrideprotected Object clone() throws CloneNotSupportedException &#123; Object obj = super.clone(); //添加如下代码实现深复制 Sheep2 s = (Sheep2) obj; s.birthday = (Date) this.birthday.clone(); //把属性也形象克隆 return obj;&#125; 然后再调用测试方法测试一下 结果： com.kid.prototype.Sheep2@4554617c 小羊 Sat Jun 04 09:03:54 CST 1977 Fri Jan 02 18:12:03 CST 1970 com.kid.prototype.Sheep2@7f31245a 大羊 Sat Jun 04 09:03:54 CST 1977 我们会发现，这个时候，s2的出生日期和s1未修改之前的日期一样，这样我们就实现了深复制。 原型模式图结构图 原型模式实现 Cloneable接口和clone方法 prototype模式中实现起来最困难的地方就是内存复制操作，所幸java中提供了clone方法替我们做了绝大部分事情。 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--建造者模式]]></title>
    <url>%2F2018%2F08%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[场景 建造一个复杂的产品 实际开发中，我们构建的对象非常复杂时 建造模式的本质 分离了对象子组件的单独构造（由Builder来负责）和装配（由Director负责），从而构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况下使用。 由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的购建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。 白话解析我们建造一个非常复杂的产品，比如说宇宙飞船时，为了在构建和组装飞船的时候‘不缺胳膊少腿’，我们需要将一个产品的内部表象和产品的生产过程分割（分批行动，较为稳妥），具体分为两步： 构建很多零件（Builder） 把零件组装起来（Director） 代码示例生成实体类先将宇宙飞船抽象化，假设有轨道舱，发动机和逃逸塔等部分，我们先定义实体类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/** * 宇宙飞船 实体类 */public class AirShip &#123; private OrbitalModule orbitalModule; //轨道舱 private Engine engine; //发动机 private EscapeTower escapeTower; //逃逸塔 /** * 发动机 */ public void launch()&#123; System.out.println("我是发动机"); &#125; public AirShip()&#123; &#125; public AirShip(OrbitalModule orbitalModule, Engine engine, EscapeTower escapeTower) &#123; this.orbitalModule = orbitalModule; this.engine = engine; this.escapeTower = escapeTower; &#125; public OrbitalModule getOrbitalModule() &#123; return orbitalModule; &#125; public void setOrbitalModule(OrbitalModule orbitalModule) &#123; this.orbitalModule = orbitalModule; &#125; public Engine getEngine() &#123; return engine; &#125; public void setEngine(Engine engine) &#123; this.engine = engine; &#125; public EscapeTower getEscapeTower() &#123; return escapeTower; &#125; public void setEscapeTower(EscapeTower escapeTower) &#123; this.escapeTower = escapeTower; &#125;&#125;/** * 轨道舱 */class OrbitalModule&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public OrbitalModule(String name) &#123; this.name = name; &#125;&#125;/** * 发动机 */class Engine&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Engine(String name) &#123; this.name = name; &#125;&#125;/** * 逃逸舱 */class EscapeTower&#123; private String name; public EscapeTower(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 构建零件定义完实体类（此处我理解为：画好图纸）以后，我们开始构建对应的组件，即建造发动机、轨道舱、逃逸塔。此处定义了接口和实现类，便于扩展和维护。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 构造方法 * 构建子组件 */public interface AirShipBuilder &#123; /** * 构建发动机 * @return */ Engine builderEngine(); /** * 构建轨道舱 * @return */ OrbitalModule builderOrbitalModule(); /** * 构建逃逸塔 * @return */ EscapeTower builderEscapeTower();&#125;/** * 构建者实现类 */public class AirShipBuilderImpl implements AirShipBuilder &#123; @Override public Engine builderEngine() &#123; System.out.println("我是发动机"); return new Engine("发动机"); &#125; @Override public OrbitalModule builderOrbitalModule() &#123; System.out.println("我是轨道舱"); return new OrbitalModule("轨道舱"); &#125; @Override public EscapeTower builderEscapeTower() &#123; System.out.println("我是逃逸舱"); return new EscapeTower("逃逸舱"); &#125;&#125; 装配呐，如果我们是建宇宙飞船的指挥者，那我们就可以站在零件生产完毕后，指挥将他们安装一定规则组装。这样，就不会出错了。123456789101112131415161718192021222324252627282930313233343536/** * 装配(组装) */public interface AirShipDirector &#123; /** * 组装宇宙飞船 * @return */ AirShip directAirship();&#125;/** * 装配者实现 */public class AirShipDirectorImpl implements AirShipDirector &#123; private AirShipBuilder airShipBuilder; public AirShipDirectorImpl (AirShipBuilder airShipBuilder)&#123; this.airShipBuilder = airShipBuilder; &#125; @Override public AirShip directAirship() &#123; Engine e = airShipBuilder.builderEngine(); OrbitalModule o = airShipBuilder.builderOrbitalModule(); EscapeTower et = airShipBuilder.builderEscapeTower(); AirShip airShip = new AirShip(); airShip.setEngine(e); airShip.setEscapeTower(et); airShip.setOrbitalModule(o); return airShip; &#125;&#125; 调用123456789101112/** * 调用者 * 建造者模式 */public class Client &#123; public static void main(String[] args) &#123; AirShipDirector director = new AirShipDirectorImpl(new AirShipBuilderImpl()); AirShip airShip = director.directAirship(); airShip.launch(); &#125;&#125; uml 类图 开发中应用场景： StringBuilder 类的append 方法 Sql中的PreparedStatement JDOM中，DomBulider、SAXBuilder 在实际应用中，可以和和工厂模式搭配.先用工厂模式构建零件，再用建造者模式装配 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序算法]]></title>
    <url>%2F2018%2F04%2F14%2F%E7%AE%97%E6%B3%95%2F%E6%8E%92%E5%BA%8F%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[快速排序基本思想通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 算法介绍 设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。一趟快速排序的算法是： 设置两个变量i、j，排序开始的时候：i=0，j=N-1； 以第一个数组元素作为关键数据，赋值给key，即key=A[0]； 从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换； 从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换； 重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。 流程假设我们将数组里插入一组数据：3 4 2 6 1 8 5 那我们将3赋值给key,此时：i=0;j=6;key=3; 首先，我们需要从后向前查找比key小的值，此时我们拿key的值，和j所在的位置的数字进行比较，3 &lt; 5，显然不满足，j– 重复第2条，直达j=4的时候，3 &gt; 1 。此时：i=0;j=4;key=3; 将i和j所在位置的值互换，此时组中的数据为1 4 2 6 3 8 5，i=0;j=4;key=3; 这时，我们需要从前往后找比key大的值，当i=1时，3 &lt; 4， 将i和j所在位置的值互换，此时组中的数据为1 3 2 6 4 8 5，i=1;j=4;key=3; 重复2-6步，直到i=j，此为一轮比较，此时，key左边的值都比key小，右边的值都比key大 3 4 2 6 1 8 5, i=0;j=6;key=3 1 4 2 6 3 8 5, i=0;j=4;key=3 后到前 1 3 2 6 4 8 5, i=1;j=4;key=3 前到后 1 2 3 6 4 8 5, i=1;j=2;key=3 后到前 1 2 3 6 4 8 5, i=2;j=2;key=3 前到后 将数据分为两组，第一组：1 2 3；第二组：6 4 8 5 ；将两组数据分别按照1-7步分别排序，此次只演示第二组数据： 6 4 8 5, i=0;j=3;key=6 5 4 8 6, i=0;j=3;key=6 后到前 5 4 6 8, i=2;j=3;key=6 前到后 5 4 6 8, i=2;j=2;key=6 后到前 5 4 6, i=0;j=2;key=5 4 5 6, i=0;j=1;key=5 后到前 4 5 6, i=1;j=1;key=5 前到后 排序完成,最后结果：1 2 3 4 5 6 8 java代码实例12345678910111213141516171819202122232425262728293031323334353637383940/** * 快速排序算法 */public class QuickAlgorithm &#123; public static void main(String[] args) &#123; int [] array = &#123;3,4,2,6,1,8,5&#125;; Quick.sort(array,0,6); System.out.println(Arrays.toString(array)); &#125;&#125;class Quick&#123; public static int partition(int []array,int lo,int hi)&#123; //固定的切分方式 int key=array[lo]; while(lo&lt;hi)&#123; //从后半部分向前扫描 while(array[hi]&gt;=key&amp;&amp;hi&gt;lo)&#123; hi--; &#125; array[lo]=array[hi]; //从前半部分向后扫描 while(array[lo]&lt;=key&amp;&amp;hi&gt;lo)&#123; lo++; &#125; array[hi]=array[lo]; &#125; array[hi]=key; return hi; &#125; public static void sort(int[] array,int lo ,int hi)&#123; if(lo&gt;=hi)&#123; return ; &#125; int index=partition(array,lo,hi); sort(array,lo,index-1); sort(array,index+1,hi); &#125;&#125; 本文代码选自：快速排序（java实现）]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金三银四java面试锦集（一）]]></title>
    <url>%2F2018%2F04%2F14%2FJava%E9%9D%A2%E8%AF%95%E9%A2%98%2F%E9%87%91%E4%B8%89%E9%93%B6%E5%9B%9Bjava%E9%9D%A2%E8%AF%95%E9%94%A6%E9%9B%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java基础1. List 和 Set 的区别 List和set同属于Collection的子类： 是否有序：List是有序的，set是无序的（TreeSet通过 Comparator 或者 Comparable 维护了一个排序顺序。） 是否重复：List是可重复的，set是不可重复的 是否为空：List允许有多个null，set只允许有一个为null 拓展： Map和List、set的区别（Map不属于Collection的子类）： Map是无序的 Map的键不允许重复，值允许重复 Map的键只允许有一个null，值允许多个null 2. HashSet 是如何保证不重复的 HashSet的底层实现结构是HashMap,它存放数据于HashMap的键中。而根据HashMap的特性，键是不允许重复的。 拓展： HashMap是以键值对存储数据的。它底层存放数据是数组+链表!每一个键，都有它相对应的唯一的hashcode码。当调用put方法放置一个key-value时，会获取键的hashcode，然后根据算法（h &amp; (length -1)），计算出应该存放的对应的数组块位置。如果多个hashcode计算出需要存放在同一数组块，则以链表的形式存储。 详情请看:HashMap的工作原理 3. HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）? HashMap是线程不安全的。hash碰撞和扩容的情况下会导致数据丢失或者形成闭环链表。 详情请看:HashMap为什么线程不安全(hash碰撞与扩容导致)、谈谈HashMap线程不安全的体现 4. HashMap 的扩容过程 计算当前数组的长度是否到最大值，如果到最大值，则修改阈值(2^31-1)之后，不会扩容 否则，初始化一个新的数组，将数据转移到新的数组里。 将新数组引用到hashmap里 修改阈值 拓展： HashMap初始容量为16，负载因子：0.75，即当前数组长度超过总长度的75%,则进行扩容。每次扩容为2的倍数。 数据转移过程（上接第二条） 遍历数组中的每一个元素 重新计算每个元素在数组中的位置 将元素放在数组上 访问下一个Entry链上的元素 1234567891011121314151617void transfer(Entry[] newTable) &#123; Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 Entry&lt;K, V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) &#123; src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do &#123; Entry&lt;K, V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 &#125; while (e != null); &#125; &#125; &#125; 详情请看：HashMap的扩容机制—resize() 5. HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？ JDK1.7中 使用一个Entry数组来存储数据，用key的hashcode取模来决定key会被放到数组里的位置，如果hashcode相同，或者hashcode取模后的结果相同（hash collision），那么这些key会被定位到Entry数组的同一个格子里，这些key会形成一个链表。在hashcode特别差的情况下，比方说所有key的hashcode都相同，这个链表可能会很长，那么put/get操作都可能需要遍历这个链表。也就是说时间复杂度在最差情况下会退化到O(n) 在扩容的时候，需要重新计算hashcode的值（hash collision），然后放到对应的数组格子里 JDK1.8中 使用一个Node数组来存储数据，但这个Node可能是链表结构，也可能是红黑树结构。如果插入的key的hashcode相同，那么这些key也会被定位到Node数组的同一个格子里。如果同一个格子里的key不超过8个，使用链表结构存储。如果超过了8个，那么会调用treeifyBin函数，将链表转换为红黑树。那么即使hashcode完全相同，由于红黑树的特点，查找某个特定元素，也只需要O(log n)的开销、也就是说put/get的操作的时间复杂度最差只有O(log n) 在扩容时候，可直接根据原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap” 详情请看：HashMap在Java1.7与1.8中的区别 6. final finally finalize final 是修饰符，关键字。被final修饰的类，就不能再派生新的子类，不能作为父类被子类继承，如String类。 finally是异常处理时，提供的finally块。不管是走try块还是catch块，都会执行finally块的代码。通常用来做清除操作或关闭流。 finalze是一个方法。java技术允许使用finalize（）方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。finalize（）方法是在垃圾收集器删除对象之前对这个对象调用的。 7. 强引用 、软引用、 弱引用、虚引用 强引用(Strong Reference),是最难被GC回收的，宁可虚拟机抛出异常，中断程序，也不回收强引用指向的实例对象。 软引用 (SoftReference)，在内存不足时，GC会回收软引用指向的对象 弱引用(WeakReference)，不管内存足不足，只要我GC,我都可能回收弱引用指向的对象 虚引用(PhantomReference )，该回收就回收，无所谓了，虚引用，我随便回收你，也叫幽灵引用，其实就是相当于没有指向任何实例对象 8. Java反射 在不用new的情况下，可以通过.class获取类中的方法和属性。 反射就是把java类中的各种成分映射成一个个的Java对象 9. Arrays.sort 实现原理和 Collection 实现原理 事实上Collections.sort方法底层就是调用的array.sort方法,Colletions.sort()实际会将list转为数组，然后调用Arrays.sort()，排完了再转回List。 JDK6里用的是快速排序，对于对象类型(Object[])，JDK6则使用归并排序 JDK7的进步到了JDK7，快速排序升级为双基准快排(双基准快排 vs 三路快排)；归并排序升级为归并排序的改进版TimSort，一个JDK的自我进化。 JDK8的进步再到了JDK8， 对大集合增加了Arrays.parallelSort()函数，使用fork-Join框架，充分利用多核，对大的集合进行切分然后再归并排序，而在小的连续片段里，依然使用TimSort与DualPivotQuickSort(双轴快排)。(TimSort算法就是找到已经排好序数据的子序列，然后对剩余部分排序，然后合并起来) 10. LinkedHashMap的应用 LinkedHashMap是HashMap的子类，它与HashMap的不同是HashMap是无序的，而LinkedHashMap维护着一个运行于所有条目的双重链接列表。 LinkedHashMap除了支持默认的插入顺序，还支持访问顺序。所谓访问顺序(access-order)是指在迭代遍历列表中的元素时最近访问的元素会排在LinkedHashMap的尾部 11. cloneable接口实现原理 Cloneable没有定义任何的接口方法，该接口在这里起到了一种标识的作用，表明实现它的类具备了实例拷贝功能。要想使一个类具备拷贝实例的功能，那么除了要重写Object类的clone()方法外，还必须要实现Cloneable接口 详情请看： JavaSE学习随笔（一） Cloneable接口源码分析与技术细节 12. 异常分类以及处理机制 Error是无法处理的异常，比如OutOfMemoryError（内存溢出），一般发生这种异常，JVM会选择终止程序。因此我们编写程序时不需要关心这类异常。 Exception也就是我们经常见到的一些异常情况，这些异常是我们可以处理的异常，是所有异常类的父类。 RuntimeException运行时异常 RuntimeNoException非运行时异常包括IOException、SQLException等 unchecked exception（非受查异常），包括Error和RuntimeException，比如常见的NullPointerException、IndexOutOfBoundsException。对于RuntimeException，java编译器不要求必须进行异常捕获处理或者抛出声明，由程序员自行决定。 checked exception（受查异常），也称非运行时异常（运行时异常以外的异常就是非运行时异常），由代码能力之外的因素导致的运行时错误。java编译器强制程序员必须进行捕获处理，比如常见的有IOExeption和SQLException。如果不进行捕获或者抛出声明处理，编译都不会通过。 处理：捕获机制：try-catch-finally 13. wait和sleep的区别 wait 休眠后会释放对象锁 sleep 休眠后不会释放对象锁 14. 数组在内存中如何分配 在堆内存中开辟一块空间，存放数组。在栈中添加引用。 本文题目提供：金三银四跳槽季，Java面试大纲 作者：占小狼]]></content>
      <categories>
        <category>java面试题</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--工厂模式]]></title>
    <url>%2F2018%2F04%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式：实现了创建者和调用者的分离 详细分类： 简单工厂模式 虽然某种程度不符合设计原则，但实际使用最多 工厂方法模式 不修改已有类的前提下，通过增加新的工厂类实现扩展。 抽象工厂模式 不可以增加产品。可以增加产品族。 应用场景 JDK中Calendar的getInstance方法 JDBC中Connection对象的获取 Hibernate中SessionFactory创建Session Spring中IOC容器创建管理bean对象 XML解析时DocumentBuilderFactory创建解析器对象 反射中Class对象的newInstance(); 面向对象的设计原则 OCP(开闭原则)：一个软件的实体应当对扩展开放，对修改关闭 DIP(依赖倒转原则)：要针对接口编程，不要针对现实编程 LOD(迪迷特法则)：只与你直接的朋友通信，而避免与陌生人通信 普通方法按照常理模式，当我们需要调用一个类的时候，我们需要通过new 一个对象来实现。那么，我在不知道工厂模式的情况下，多半是直接new，然后直接调用了。在此我就叫我的方法为普通方法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 定义Car接口 */public interface Car &#123; void run();&#125;/** * 实现Car接口 * 比亚迪 */public class Byd implements Car&#123; @Override public void run() &#123; System.out.println("比亚迪在跑"); &#125;&#125;/** * 实现Car接口 * 奥迪 */public class Audi implements Car&#123; @Override public void run() &#123; System.out.println("奥迪在跑"); &#125;&#125;/** * 使用普通方法调用比亚迪和奥迪类 * 结果： * 奥迪在跑 * 比亚迪再跑 */public class Client01 &#123; public static void main(String[] args) &#123; Car c1 = new Audi(); Car c2 = new Byd(); c1.run(); c2.run(); &#125;&#125; 该方法虽然简单，但是显然没有使用遵循面向对象设计的基本原则嘛。为了提高自我代码的质量，还是要学习设计模式，并在日常编程中运用。 简单工厂模式那么，要想提高，我们先来看一下简单工厂模式的类图： 如上图所示：和我们的简单方法是不是差了点什么？没错，我们缺少CarFactory类。那我们先来看下CarFactory和他的调用 1234567891011121314151617181920212223242526272829303132/** * 简单工厂类 * 缺点：不完全满足OCP */public class CarFactory &#123; public static Car getCar(String type)&#123; if ("奥迪".equals(type))&#123; return new Audi(); &#125;else if ("比亚迪".equals(type))&#123; return new Byd(); &#125;else &#123; return null; &#125; &#125;&#125;/** * 使用简单方法调用比亚迪和奥迪类 * 结果： * 奥迪在跑 * 比亚迪再跑 */public class Client02 &#123; public static void main(String[] args) &#123; Car c1 = CarFactory.getCar("奥迪"); Car c2 = CarFactory.getCar("比亚迪"); c1.run(); c2.run(); &#125;&#125; 在调用的时候，我们可以不必需要什么而new什么，我们只需要将参数传递过去，简单工厂会自动返回我们想要的对象。是不是灵活了很多！当然，这也就是所谓的找对象原则，我原先找对象，得自己找，苦苦的找，还不一定能找到。之后呢，出现这种找对象的平台了，我不用自己跑出去找了，我跟这个平台说一声，我想要长得好看的，个子高的，肤白貌美的。恩，这个平台就会给我找到。（ps:这个比喻忘记是看哪个仁兄的比喻，暂且借用。知道后标注。）这就是我们的工厂模式。 工厂方法模式看了简单工厂，我们来了解下工厂方法模式: 简单工厂模式只有一个工厂类，而工厂方法模式有一组实现了相同接口的工厂类。 对比简单工厂模式：增加了工厂接口，通过不同的工厂类来实现工厂模式。如下图所示： 对比简单模式，我们增加了一个工厂接口，然后实现不同的工厂，这个时候，我们的调用者Client不需要知道Car的接口，只需要知道Car工厂的接口，就可以调用。是不是更加深层次的解耦代码了。这样有什么好处呢，假如我使用简单工厂模式，在我增加一个产品的时候，比如，我增加宝马，那Car的工厂类得进行修改。而使用工厂方法模式，那么我们只需要增加一个宝马的工厂类就行。但是，这样也有一个缺点，就是文件太多，不利于管理。 抽象工厂模式 用来生产不同产品族的全部产品（对于增加的新的产品，无能为力；支持增加产品族） 抽象工厂模式是工厂方法模式的升级版本，在由多个业务品种，业务分类时，通过抽象工厂模式需要的对象是一种非常好的解决方式。 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础--反射]]></title>
    <url>%2F2018%2F03%2F26%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80--%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[什么是反射：java通常是先有类再有对象，有对象我就可以调用方法或者属性。反射其实是通过Class对象来调用类里面的方法。通过反射可以调用私有方法和私有属性。大部分框架都是运用反射原理。 反射的作用：动态的加载类和类中的信息 反射小例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384@SuppressWarnings("all")public class ReflexTestDemo &#123; public static void main(String[] args)&#123; String path = "com.tfs.test.User"; User user = new User(); try &#123; //一、获取对象的方式 Class&lt;User&gt; cl1 = (Class&lt;User&gt;) Class.forName(path); Class cl2 = User.class; Class cl3 = user.getClass(); System.out.println(cl1.hashCode() == cl2.hashCode()); //true System.out.println(cl1.hashCode() == cl3.hashCode()); //true //二、获取并使用对象内置信息 //1.获取名称 System.out.println(cl1.getName()); //com.tfs.test.User System.out.println(cl1.getSimpleName()); //User //2.获取并使用属性 Field[] fields = cl1.getFields(); //只能获取public的 Field[] fields1 = cl1.getDeclaredFields(); //获取全部的 Field field = cl1.getDeclaredField("name"); //根据名字获取 User u2 = cl1.newInstance(); //利用反射获取默认构造方法 field.setAccessible(true); //设置后可以不用进行安全检测，提高性能 field.set(u2,"kid"); //给name属性赋值kid System.out.println(field.get(u2)); //输出：kid //3.获取并使用普通方法 Method method = cl1.getDeclaredMethod("setName", String.class); //参数：方法名，方法参数 User u3 = cl1.newInstance(); method.invoke(u3,"kid"); //等同于 u3.setName("kid"); 方法 System.out.println(u3.getName()); //输出：kid //4.获取并使用构造方法 Constructor constructor1 = cl1.getDeclaredConstructor(); //获取无参构造方法 Constructor constructor2 = cl1.getDeclaredConstructor(int.class,String.class); //获取有参构造方法 User u4 = (User) constructor2.newInstance(1008,"kid"); //调用该方法并传参 System.out.println(u4.getName()); //输出：null 所以该方法只是调用了有参的构造函数，并未真正的传参 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;/** * @Description:被调用的User类 * @Author:kid * @Date: 2018/3/26 16:17 * @ISDELETE: NO */public class User &#123; public int id; String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public User()&#123; &#125; public User(int id,String name)&#123; &#125; 反射性能反射的会影响运行的速度，但是在开发中，有一些地方还是会需要反射。那么如何解决这个问题呢？经测验：在同时循环执行一个方法的时候，反射会比普通的方法慢很多。如将setAccessible设置为true，减少安全检测，将提升4倍的效率。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础--注解]]></title>
    <url>%2F2018%2F03%2F26%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80--%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解 什么叫做注解？注解-&gt;Annotation，JDK5.0引入技术 Annotation 的作用： 并不是程序本身，可以对程序作出解释。 可被其他程序读取（可做信息处理） 内置注解 @Override : 定义在java.lang.Override中，此注释只适用于修辞方法，表示一个方法声明打算重写父类中另一个方法声明。 @Deprecated：定义在java.lang.Deprecated中，此注释用于修辞方法、熟悉、类。表示不鼓励程序员使用这样的元素。 @SuppressWarnings：用来抑制编译时的警告信息。其中包含的参数： deprecation 使用了过时的类或方法的警告 unchecked 执行了未检查的转化时的警告，如使用集合时，未指定泛型 元注解（对注解进行进一步解释） @Target：用于描述注解的使用范围（如包、类、方法等） CONSTRUCTOR:用于描述构造器 FIELD:用于描述域 LOCAL_VARIABLE:用于描述局部变量 METHOD:用于描述方法 PACKAGE:用于描述包 PARAMETER:用于描述参数 TYPE:用于描述类、接口(包括注解类型) 或enum声明 @Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期 SOURCE:在源文件中有效（即源文件保留） CLASS:在class文件中有效（即class保留） RUNTIME:在运行时有效（即运行时保留） 自定义注解新建一个Annotation 方法，方法头加元注解，具体如下：12345678910111213141516@Target(value = ElementType.METHOD) //该注解只可放在方法前面@Retention(RetentionPolicy.RUNTIME) //可以通过反射读取到public @interface Annotation &#123; //定义参数默认值 String studentName() default ""; int age() default 0; int id() default -1; String[] schools() default &#123;&#125;;&#125;/* 引用该注解*/ @Annotation(age = 18,studentName = "二狗",id = 1008, schools = &#123;"北京大学","清华大学"&#125;) public void test()&#123; &#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github博客搭建]]></title>
    <url>%2F2018%2F03%2F25%2F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%2Fgithub%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[最近看别人都搭建了属于自己的博客，心生羡慕。于是也抽空捣鼓一个。此次个人博客搭建是利用github平台搭建博客。下面主要讲述搭建过程及遇到的坑。 准备工作github到位在github官网上申请账号。记住注册的邮箱。在注册成功后，可以选择建一个项目。此次搭建一个公共的项目（私有的貌似得花钱）。注： 项目名称必须为你注册的名称加github.io，如我的项目名为 kid-297.github.io github需要和git建立连接，需要在本地生成ssh秘钥。如果在之前你有生成ssh公钥，那么就可以直接提交上去，如果没有，则需要填写邮箱以及密码进行生成（详情请看我文章 git配置） git到位众所周知，git是一个分布式版本控制系统。而我们此次项目的上传下载到github等工作，非他莫属。git的具体安装方式，请自行百度。 node.js到位据说node.js的功能很强大啊！但具体多强大我也不甚了解啊！至于在这安装node.js干嘛，主要是想用hexo啊！安装方式也不具体说了哈。 hexo到位使用hexo呢，主要是因为Hexo是一个开源的静态博客生成器。自带很多模板，可供广大网友自行选择。 hexo搭建过程 打开cmd并输入npm install -g hexo 在你要存放hexo的地方新建一个空文件夹名为hexo cmd安装完成之后右键打开Git bash（此时要求git已经安装好了） 在Git 的运行框中进入cd 进入hexo文件夹后输入$ hexo init 如果你按照上述步骤一套做完，那么恭喜你，hexo已经搭建成功，是不是很简单？ 本地运行hexo安装完hexo之后你就能在本地查看你的空hexo blog了在cmd中输入$ hexo s –debug（debug可以不写）随后你在浏览器地址栏输入http://localhost:4000/hexo默认主题landscape就呈现在你眼前了注：hexo s是hexo server的缩写 至此，本地的环境已经搭建完毕。可以考虑上传到github上或者给你的博客更换主题了。 提交至GitHub首先进入hexo文件夹，找到根目录下面的_config.yml文件,用编辑器打开它找到deploy。部署至GitHub需要填如下：1234deploy: type: git repository: git@github.com:kid-297/kid-297.github.io.git branch: master 注：.yml文件格式严格，在“：”之后一定要空格再输入，如果不填入内容则是默认值。文中kid-297请自行跟换成自己的用户名。 创建完成后打开Git bash按下ctrl+c并输入y结束hexo的本地预览。之后进入你的hexo文件夹，输入$ hexo generate（用于生成静态网页文件，可缩写成$ hexo g） 接着输入$ hexo deploy（可缩写成hexo d） 更改hexo主题如果你对hexo默认主题不满意，你也可以自己寻找主题包甚至是自己制作。具体使用方法请移步：hexo博客更换主题（原理一样，只是主题不同） 发布文章输入$ hexo new “博客名”创建成功之后，点击进入hexo文件夹的source文件夹，找到_posts文件夹，进入用编辑器打开你刚刚创建的.md文件，你将看到如下代码 title:date:tags: 在title后面填写文章名，注意空格，tags用来设置文章标签，格式为[标签一,标签二] 设置完之后就开始使用Markdown语法进行博客创作吧 文章写好后： hexo s 启动本地项目访问查看效果（http://localhost:4000/） hexo g 生成新的静态页面 hexo d 发布到github上去 其他常见的hexo命令 $ hexo clean #清除缓存 $ hexo generate –watch #监视文件变动 $ hexo new page “页面名” #新建页面 注 ： 本博客大部分出自于强大的hexo–如何利用hexo平台搭建个人博客 感谢作者，解我搭建之坑，特此记录！]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>博客</tag>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git配置]]></title>
    <url>%2F2018%2F03%2F25%2F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%2Fgit%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[如何配置git 生成并部署SSH key打开git bash,输入以下命令生成 SSH Keyssh-keygen -t rsa -C “xxxxx@xxxxx.com“ （该邮箱为Github/GitLab注册邮箱） 在相应的.ssh目录下会生成名为id_rsa私钥文件和id_rsa.pub公钥文件， 打开id_rsa.pub公钥文件,复制里面的公钥添加到Github/GitLab的添加SSH秘钥处。 然后在git bash中输入以下命令测试Github/GitLab的SSH秘钥是否部署成功。ssh -T git@github.com 出现以下提示，表示部署Github/GitLab的SSH key成功 Hi kid-297! You’ve successfully authenticated, but GitHub does not provide shell access. 如何配置多个git在工作和学习时候，难免会遇到一台电脑同时使用多个Github/GitLab的情况。下面讲述下如何配置多个。 如上已经配置生成好了一个公钥和私钥。我们在生成第二个或者更多个的时候，需要起不同的名字。不能再使用默认的文件名id_rsa， 否则会覆盖之前的gitLab的秘钥文件。 这里保存为id_rsa_work：ssh-keygen -t rsa -f ~/.ssh/id_rsa_work -C “xxxxx@xxxxx.com“ 这时候就会在.ssh目录下又生成一对公私钥文件,同样是打开公钥文件id_rsa_work .pub，复制里面的公钥添加到Github/GitLab SSH秘钥处。 添加秘钥到SSH Agent因为默认只读取id_rsa,为了让SSH识别新的私钥，需将其添加的SSH agent中。ssh-agent bashssh-add ~/.ssh/id_rsassh-add ~/.ssh/id_rsa_work 创建并配置config文件在.ssh目录下创建一个config文本文件,添加相关配置。每个账号单独配置一个Host，每个Host要取一个别名，每个Host主要配置HostName和IdentityFile两个属性即可。 我的配置12345678910111213141516# githubHost githubHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa# work githubhost gitlab#这个是真实的域名地址 HostName (此处填写GitLab的IP或者网址)#配置使用用户名User kid# 配置登录时用什么权限认证 可设为publickey,password publickey,keyboard-interactive等 PreferredAuthentications publickey#这里是id_rsa的地址IdentityFile ~/.ssh/id_rsa_work 这个时候再通过终端测试是否部署SSH Key成功 注：用户名和邮箱的配置因为一台电脑上配置了多个git账号，所以就不能再配置全局的用户名和邮箱了，而是在不同的仓库下，如果需要连接不同的git账号,配置相应的局部用户名和邮箱即可，如果之前配置过全局的用户名和邮箱,需要取消配置git config –global –unset user.namegit config –global –unset user.email 配置局部的用户名和邮箱git config user.name “xxxx”git config user.email “xxxx@xx.com“ 注：本博客大部分内容出自 windows下在一台电脑上配置多个git账号。感谢作者，解我搭建之坑，特此记录！]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式GOF23--单例模式]]></title>
    <url>%2F2018%2F03%2F24%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FGOF23-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[名词解析：GOF--&gt;Group Of Four 四人帮 设计模式共分为以下几种模式： 创建型模式： 单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式 结构型模式： 适配器模式、桥接模式、装饰者模式、组合模式、外观模式、享元模式、代理模式 行为模式： 模板方法模式 、命令模式、装饰模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式。状态模式、策略模式、职责链模式、访问者模式 核心作用保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。 常见的应用场景 windows的任务管理器、回收站 项目中的读取配置文件的类，数据库连接池，一般也只有一个对象。 应用程序中的日志应用、网站中的计数器 Applicathion和每个Servlet也是单例 Spring中，每个Bean也是单例的 Spring MVC框架/Struts框架中，控制对象也是单例 单例模式的优点 减少性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖方式时，则可以通过在应用中启动时直接产生一个单例对象，然后永久驻留在内存的方式来解决。 单例模式可以在系统中设置全局的访问点，优化共享资源访问 常见的5种单例模式实现方式： 主要： 饿汉模式（线程安全，调用率高。不能延时加载） 懒汉模式（线程安全，调用率低。可以延时加载） 其他： 双重检索锁式（由于JVM底层内部模型原因，偶尔会出现问题。不建议使用） 静态内部类式（线程安全、调用率高、可以延时加载） 枚举单例（线程安全、调用率高、不能延时加载） 饿汉模式（立即加载）1234567891011public class SingletonDemo1&#123; //1.实现私有的构造器，别人不可调用 private SingletonDemo1()&#123;&#125; //2.实现一个私有的对象。 类初始化时，立即加载这个对象！由于加载类时，天然的是线程安全的 private static SingletonDemo1 instance = new SingletonDemo1(); //3.提供一个开放方法。 方法没有同步，调用效率高 public static SingletonDemo1 getInstance()&#123; return instance; &#125;&#125; 问题：如果只是加载本类，但是没有调用getInstance方法， 则会造成资源浪费 懒汉模式(延迟加载/懒加载)1234567891011121314public class SingletonDemo2&#123; //1.实现私有的构造器，别人不可调用 private SingletonDemo2()&#123;&#125; //2.实现一个私有的对象。 类初始化时，不初始化这个对象！真正用的时候创建 private static SingletonDemo2 instance; //3.提供一个开放方法。 方法同步，调用效率低 public static synchronized SingletonDemo1 getInstance()&#123; if(instance == null)&#123; instance = new SingletonDemo2(); &#125; return instance; &#125;&#125; 问题：资源利用率高了，但是每次调用getInstance方法都需要同步，并发效率较低。 双重检索锁式123456789101112131415161718192021222324252627class SingletonDemo3 &#123; private static SingletonDemo3 instance = null; public static SingletonDemo3 getInstance() &#123; if (instance == null) &#123; SingletonDemo3 sc; synchronized (SingletonDemo3.class) &#123; sc = instance; if (sc == null) &#123; synchronized (SingletonDemo3.class) &#123; if(sc == null) &#123; sc = new SingletonDemo3(); &#125; &#125; instance = sc; &#125; &#125; &#125; return instance; &#125; private SingletonDemo3() &#123; &#125;&#125; 静态内部类123456789101112131415161718/** * 静态内部类式 * 线程安全、调用率高、可以延时加载 */class SingLetonStatic&#123; //定义静态内部类 private static class SingletonClassInstance&#123; private static final SingLetonStatic singLetonStatic = new SingLetonStatic(); &#125; private SingLetonStatic()&#123; &#125; public static SingLetonStatic getInstance()&#123; return SingletonClassInstance.singLetonStatic; &#125;&#125; 枚举12345678910111213/** * 枚举 * 线程安全、调用率高、不能延时加载 */enum SingLetonEnum&#123; //这个枚举元素，本身就是单例对象 INSTANCE; public void SingLetonEnumOp()&#123; &#125;&#125; 注：该博文为学习总结，视频来源为高淇java300集]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web消息通讯方式--即时聊天]]></title>
    <url>%2F2018%2F03%2F21%2Fjava%20EE%2Fweb%E6%B6%88%E6%81%AF%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F-%E5%8D%B3%E6%97%B6%E8%81%8A%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[之前在一个项目中涉及到即时聊天功能，特此记录下当时的解决方法。 目前web上的消息通讯方式主要有以下几种。轮询，长连接，websocket 轮询：隔一段时间访问服务器，服务器不管有没有新消息都立刻返回。 长连接：页面向服务器发出请求，由服务器决定什么时候返回。（如果有新消息则立刻返回，没有的话就保持连接，直到有新消息才返回） websocket：类似Java Socket，由Http请求模拟实现的socket。 本次使用轮询方法做解决以下是轮询的代码：123456789101112131415161718192021222324252627 //返回未读json列 实现实时聊天 延迟1s //超时链处理 原则上和session保持一致 （例如session30分钟 180 000 毫秒） Integer sessionsec = 1800000; Integer sessionstop = 0; boolean isnewmess = false;//1.此处判断是否有新的聊天数据更新 if(isnewmess)&#123; // 返回消息内容 &#125;else&#123; //2.执行循环操作 while (isnewmess==false) &#123; //2.1 如果没有继续判断（节省服务器开销 进行休眠2 秒 为了保证实时性） sessionstop +=2000; if (sessionstop&gt;=sessionsec) &#123; isnewmess = true; //此处销毁链接 返回特征码 &#125;else&#123; Thread.sleep(1000); //此处判断是否有新的聊天数据更新 if (isnewmess) &#123; //返回消息内容 break; &#125; &#125; &#125; &#125;]]></content>
      <categories>
        <category>JAVA EE</category>
      </categories>
      <tags>
        <tag>即时聊天</tag>
      </tags>
  </entry>
</search>
